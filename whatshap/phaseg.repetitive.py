"""
create association between reads and bubbles.
"""
import pyfaidx

from xopen import xopen
import stream
import logging
from . import vg_pb2
from collections import Counter

from collections import defaultdict
from .core import ReadSet, Read
from functools import reduce
import operator as op

import random
import collections
from collections import OrderedDict, namedtuple


from contextlib import ExitStack
from .vcf import VcfReader, PhasedVcfWriter
from . import __version__
from .core import PyIndexSet as IndexSet
from .core import ReadSet, readselection, Pedigree, PedigreeDPTable, NumericSampleIds, PhredGenotypeLikelihoods
from .graph import ComponentFinder
from .pedigree import (PedReader, mendelian_conflict, recombination_cost_map,
                       load_genetic_map, uniform_recombination_map, find_recombination)
from .bam import BamIndexingError, SampleNotFoundError
from .timer import StageTimer
from .variants import ReadSetReader, ReadSetError
from heapq import heappush, heappop
from itertools import count


__author__ = "Shilpa Garg, Tobias Marschall"

logger = logging.getLogger(__name__)


class CoverageMonitor:
        '''TODO: This is a most simple, naive implementation. Could do this smarter.'''
        def __init__(self, length):
                self.coverage = [0] * length

        def max_coverage_in_range(self, begin, end):
                return max(self.coverage[begin:end])

        def add_read(self, begin, end):
                for i in range(begin, end):
                        self.coverage[i] += 1

def slice_reads(reads, max_coverage):
	"""
	Iterate over all read in random order and greedily retain those reads whose
	addition does not lead to a local physical coverage exceeding the given threshold.
	Return a ReadSet containing the retained reads.

	max_coverage -- Slicing ensures that the (physical) coverage does not exceed max_coverage anywhere along the chromosome.
	reads -- a ReadSet
	"""
	
	SEED = 448
	random.seed(SEED)
	shuffled_indices = list(range(len(reads)))
	random.shuffle(shuffled_indices)

	position_list = reads.get_positions()
	logger.info('Found %d SNP positions', len(position_list))

	# dictionary to map SNP position to its index
	position_to_index = { position: index for index, position in enumerate(position_list) }

	# List of slices, start with one empty slice ...
	slices = [IndexSet()]
	# ... and the corresponding coverages along each slice
	slice_coverages = [CoverageMonitor(len(position_list))]
	skipped_reads = 0
	accessible_positions = set()
	for index in shuffled_indices:
		read = reads[index]
		# Skip reads that cover only one SNP
		if len(read) < 2:
			skipped_reads += 1
			continue
		for position, base, allele in read:
			accessible_positions.add(position)
		first_position, first_base, first_allele = read[0]
		last_position, last_base, last_allele = read[len(read)-1]
		begin = position_to_index[first_position]
		end = position_to_index[last_position] + 1
		slice_id = 0
		while True:
			# Does current read fit into this slice?
			if slice_coverages[slice_id].max_coverage_in_range(begin, end) < max_coverage:
				slice_coverages[slice_id].add_read(begin, end)
				slices[slice_id].add(index)
				break
			else:
				slice_id += 1
				# do we have to create a new slice?
				if slice_id == len(slices):
					slices.append(IndexSet())
					slice_coverages.append(CoverageMonitor(len(position_list)))
	logger.info('Skipped %d reads that only cover one SNP', skipped_reads)

	unphasable_snps = len(position_list) - len(accessible_positions)
	if position_list:
		logger.info('%d out of %d variant positions (%.1d%%) do not have a read '
			'connecting them to another variant and are thus unphasable',
			unphasable_snps, len(position_list),
			100. * unphasable_snps / len(position_list))

	# Print stats
	for slice_id, index_set in enumerate(slices):
		logger.info('Slice %d contains %d reads', slice_id, len(index_set))

	return reads.subset(slices[0])

def find_components(phased_positions, reads, master_block=None):
	"""
	Return a dict that maps each variant position to the component it is in.
	Variants are considered to be in the same component if a read exists that
	covers both. A component is identified by the position of its leftmost
	variant.
	master_block -- List of positions in a "master block", i.e. all blocks containing
	                any of these positions are merged into one block.
	heterozygous_positions -- A dictionary mapping numeric sample ids to sets of
	                          positions. Component building is then restricted to variants
	                          at these positions. If none, all variants are used.
	"""
	logger.debug('Finding connected components ...')
	assert phased_positions == sorted(phased_positions)

	# Find connected components.
	# A component is identified by the position of its leftmost variant.
	component_finder = ComponentFinder(phased_positions)
	phased_positions = set(phased_positions)
	for read in reads:
		positions = [ variant.position for variant in read if variant.position in phased_positions ]
		for position in positions[1:]:
			component_finder.merge(positions[0], position)
	if not master_block is None:
		for position in master_block[1:]:
			component_finder.merge(master_block[0], position)
	components = { position : component_finder.find(position) for position in phased_positions }
	return components


def find_largest_component(components):
	"""
	Determine the largest component and return a sorted list of positions
	contained in it.
	components -- dictionary mapping positin to block_id as returned by find_components.
	"""
	blocks = defaultdict(list)
	for position, block_id in components.items():
		blocks[block_id].append(position)
	largest = []
	for block in blocks.values():
		if len(block) > len(largest):
			largest = block
	largest.sort()
	return largest
      

"""
output the possible allele-pairs for a bubble.
"""
def ncr(n, r):
    r = min(r, n-r)
    if r == 0: return 1
    numer = reduce(op.mul, range(n, n-r, -1))
    denom = reduce(op.mul, range(1, r+1))
    return numer//denom
  

"""
build node-sequence list for vg graph
"""
def vg_graph_reader(vg_file):
	node_seq_list= defaultdict()
	edge_connections = defaultdict(list)
	with stream.open(str(vg_file), "rb") as istream:
		for data in istream:
			l = vg_pb2.Graph()
			l.ParseFromString(data)
			for i in range(len(l.node)):
				index = l.node[i].id
				seq = l.node[i].sequence
				node_seq_list[index]=seq
			for j in range(len(l.edge)):
				from_edge = getattr(l.edge[j], "from")
				edge_connections[from_edge].append(l.edge[j].to)
	return node_seq_list, edge_connections


def find_matches(pattern_list, search_list):
	cursor_list = []
	found = []
	for i in range(len(search_list)):
		element = search_list[i]
		cursors_to_kill = []
		for cursor_index in range(len(cursor_list)):
			if element == pattern_list[cursor_list[cursor_index]]:
				if i not in found:
					found.append(i)
				cursor_list[cursor_index] += 1
				if cursor_list[cursor_index] == len(pattern_list):
					return found
			else:
				if len(cursor_list) == 1:
					found = []
				cursors_to_kill.append(cursor_index)
		cursors_to_kill.reverse()
		for cursor_index in cursors_to_kill:
			cursor_list.pop(cursor_index)
		if element == pattern_list[0]:
			if len(found) == 0:
				found.append(i)
			cursor_list.append(1)
		#print('i=%d: %s: %s' % (i, ",".join([str(x) for x in cursor_list]), ",".join([str(x) for x in found])))
	return found


def fuzzy_trincot(haystack, needle, returnSegments = False):
	inf = float('inf')

	def getSolutionAt(node, depth, optimalCount = 2):
		if not depth: # reached end of needle
			node['count'] = 0
			return
		minCount = inf # infinity ensures also that incomplete branches are pruned
		child = node['child']
		i = node['i']+1
		# Optimisation: optimalCount gives the theoretical minimum number of
		# segments needed for any solution. If we find such case,
		# there is no need to continue the search.
		while child and minCount > optimalCount:
			# If this node was already evaluated, don't lose time recursing again.
			# It works without this condition, but that is less optimal.
			if 'count' not in child:
				getSolutionAt(child, depth-1, 1)
			count = child['count'] + (i < child['i'])
			if count < minCount:
				minCount = count
			child = child['sibling']
		# Store the results we found in this node, so if ever we come here again,
		# we don't need to recurse the same sub-tree again.
		node['count'] = minCount

	# Preprocessing: build tree
	# A node represents a needle character occurrence in the haystack.
	# A node can have these keys:
	#   i:	   index in haystack where needle character occurs
	#   child:   node that represents a match, at the right of this index,
	#			for the next needle character
	#   sibling: node that represents the next match for this needle character
	#   count:   the least number of additional segments needed for matching the
	#			remaining needle characters (only; so not counting the segments
	#			already taken at the left)
	root = { 'i': -2, 'child': None, 'sibling': None }
	# Take a short-cut for when needle is a substring of haystack
	if needle in haystack:
		root['count'] = 1
	else:
		parent = root
		leftMostIndex = 0
		rightMostIndex = len(haystack)-len(needle)
		for j, c in enumerate(needle):
			sibling = None
			child = None
			# Use of leftMostIndex is an optimisation; it works without this argument
			# i = haystack.find(c, leftMostIndex)
			try:
				i = haystack.index(c, leftMostIndex)
				#print("initial value of i " + str(i))
			except:
				i = -1
			#sys.stdout.write('i=%d\n' % i); sys.stdout.flush()
			# Use of rightMostIndex is an optimisation; it works without this test
			while 0 <= i <= rightMostIndex:
				#print("line 62" + str(i))
				node = { 'i': i, 'child': None, 'sibling': None }
				while parent and parent['i'] < i:
					parent['child'] = node
					parent = parent['sibling']
				if sibling: # not first child
					sibling['sibling'] = node
				else: # first child
					child = node
					leftMostIndex = i+1
				sibling = node
				# i = haystack.find(c, i+1)
				try:
					i = haystack.index(c, i+1)
					#print("line 75" + str(i))
				except:
					i = -1
					#print("received exception")
			if not child: return False
			parent = child
			rightMostIndex += 1
		getSolutionAt(root, len(needle))

	count = root['count']
	if not returnSegments:
		return count

	# Use the `returnSegments` option when you need the character content
	# of the segments instead of only the count. It runs in linear time.

	segments_index = []
	if count == 1: # Deal with short-cut case
		segments_index.append(0)
		segments_index.append(len(needle))
		return [needle], segments_index

	segments = []
	node = root['child']
	i = -2
	start = 0
	for end, c in enumerate(needle):
		i += 1
		# Find best child among siblings
		while (node['count'] > count - (i < node['i'])):
			node = node['sibling']
		if count > node['count']:
			count = node['count']
			if end:
				segments.append(needle[start:end])
				segments_index.append(start)
				segments_index.append(end)
				start = end
		i = node['i']
		node = node['child']
	segments.append(needle[start:])
	segments_index.append(start)
	segments_index.append(len(needle))
	return segments, segments_index
"""
Output phased SnarlTraversal using superreads_list. 
Then take input vg graph and phased SnarlTraversal to reconstruct underlying two sequences.
"""
"""
Input: Phase variants from Locus file and aligned reads from GAM file.

It creates an association between het variants and read alignments. 

Output: The optimal partitioning is written to standard output.
"""
def vg_reader(locus_file, gam_file, canu_alignments):
	"""
	input: sorted locus and sorted GAM file output from vg.
	output: sorted readset for core DP.
	assumptions: 
	1. locus file consists of linear ordering of simple bubbles only and hence sorted. Each locus file does not contain start and end vertex.
	2. paths in the locus should be covered by atleast one pacbio read.
	2. GAM file is sorted and restricted to locus file.
	3. files consists of all DAG connected components.
	4. add variant only when it identifies the branch uniquely.
	"""
	# create a dictionary of branches for each locus based on locus file.
	#nodes_list = set()
	#for line in open('canu_contigs.nodes'):
	#	nodes_list.add(int(line.rstrip()))

	locus_count=0
	prev_startsnarl = 0
	prev_endsnarl = 0
	locus_branch_mapping=OrderedDict()
	start_node_to_bubbleid = defaultdict()
	locus_count=0
	prev_startsnarl = 0
	prev_startsnarl_orientation = -1
	prev_endsnarl = 0
	prev_endsnarl_orientation = -1
	with stream.open(str(locus_file), "rb") as istream:
		for data in istream:
			l = vg_pb2.SnarlTraversal()
			l.ParseFromString(data)
			#TODO: make ordered doctionary locus_branch_mapping
			# handle forward and backward case of nodes
			current_startsnarl = l.snarl.start.node_id
			current_startsnarl_orientation = l.snarl.start.backward
			current_endsnarl = l.snarl.end.node_id
			current_endsnarl_orientation = l.snarl.end.backward
			path_in_bubble =[]
			# from simulated whole yeast genome based on reads.
			# only remove tandom repeats.
			cyclic_bubbles_file = open('assembly_graph.P.int.remn2n.X_100.chrXIII.onlytandom.rep_bubbles', 'r')
			cyclic_bubbles1 =set()
			#for line in cyclic_bubbles_file:
			#	x = line.rstrip()
			#	cyclic_bubbles1.add(int(x))
			#out.gam
			cyclic_bubbles = []
			#cyclic_bubbles = [98306,98307,98308,98309,98310,98311,98312,98313,98314,98315,98316,98317,98318,98319,98320,98321,98322,98323,98324,98325,98326,98327,98328,98329,98330,98331,98332,98333,98334,98335,98336,98337,98338,98339,98340,98341,98342,98343,98344,98345,98346,98347,98348,98349,98350,98351,98352,98353,98354,98355,98356,98357,98358,98359,98360,98361,98362,98363,98364,98365,98366,98367,98368,98369,155710,98370,131140,131141,131142,131143,139335,131145,131146,131147,131148,131144,139333,98384,98385,98386,98387,98388,98389,98390,98391,98392,98397,98398,98399,98400,98401,98402,98403,98404,98405,98406,98407,98408,98411,98412,98413,110741,110742,110743,110744,180350,110745,110746,110747,110748,97723,98454,98455,98456,98457,98458,98459,196764,98460,98461,196767,98462,98463,98464,98465,98466,98467,98468,98469,98471,98473,98474,98475,98476,98472,98470,98479,98480,98481,98482,98483,98484,98485,98486,98487,98488,98489,98490,98491,98492,98493,98494,98495,98496,98497,98498,98499,98500,98501,98502,98503,98504,98505,98506,98573,98574,98575,98579,131349,131350,131352,131353,131355,131356,139549,303390,303391,303392,303393,303394,303395,196914,107145,245926,188745,245927,262478,262479,262480,262481,98643,98644,98645,98647,98648,98649,98650,98651,98652,98653,98654,98655,98656,98657,98658,98659,107147,107148,221567,98689,98690,107149,229799,110732,229843,229844,106967,106968,106969,106970,106971,106972,106973,106974,106975,106976,106977,106978,106980,98818,98819,98820,98821,98822,98823,98824,98825,98826,98827,98828,98829,98830,98831,139787,139785,98833,98832,139798,139799,139800,139801,139802,98838,139804,139805,139806,107031,180769,180770,180771,180773,180774,205351,180776,205352,180778,180779,180781,148016,189008,98901,98902,107095,98904,98905,98906,98907,98908,98909,98910,98911,98912,98913,98914,98915,98916,98917,131686,131687,131688,131689,131690,115307,115308,115309,115310,115311,115312,115313,115314,131698,115316,115317,115318,115319,107128,107129,107130,107131,115324,115325,115326,115327,115328,115329,115330,115331,115332,107141,107142,107143,115333,115334,115335,115339,115336,115337,107150,107151,107152,107153,107154,107155,107156,107157,107158,107159,107160,107161,107162,107163,107164,107165,107166,107167,107168,107169,107170,107171,213697,213698,148181,148182,148183,148184,140024,107297,107298,107299,107300,107301,107302,107304,223229,223230,205623,205624,205625,223231,223232,223233,222028,222029,110749,189291,110750,131957,131958,131959,131956,131963,131964,131965,222079,140232,246737,107503,107504,156667,156668,156669,107526,107527,107528,107529,107530,107531,107532,107533,107534,132111,115727,115728,115729,115315,214037,174429,154423,181279,181280,174430,181281,104416,104417,174431,164904,104418,174432,104419,174433,255027,255028,255029,255030,255031,255032,255033,255034,255035,255036,174435,174434,104421,174436,104422,104423,104424,174438,104425,104426,123991,123992,123993,104427,104428,123997,104429,104430,104431,189550,104432,104433,164995,246923,143517,104440,222362,104441,238752,104442,173221,104443,104444,337069,337070,337071,104445,146908,197818,197820,197821,165053,165054,197822,165058,244478,124129,124130,124131,124132,124133,124134,124135,124136,124137,124138,124139,124140,124141,124142,124143,115952,115953,115954,115955,124148,115956,115957,124151,115959,115961,115962,115963,115964,115965,115966,115967,115968,115960,115970,99615,99616,214306,214307,214308,214309,214310,99623,214312,214313,214314,99624,99622,99626,99621,156977,99638,99639,99640,99641,99642,99643,99644,99645,99648,99649,99650,99651,99653,99654,99655,99656,99657,99658,99659,99660,99661,99663,99664,99665,99666,329045,329046,230775,173467,116130,104493,171251,116140,116141,116142,116143,116144,116145,116146,116147,116148,116149,116151,116152,116153,116154,116155,116156,116157,116158,206278,198088,198089,198090,99787,99788,99789,99790,99791,99792,99793,99794,140747,99796,99797,140749,99799,99800,99801,99802,99803,99804,124381,124382,124383,124384,124385,124386,124387,99620,132572,173575,280075,280076,280077,280078,280079,280080,280081,280082,280083,
#280084,280085,280086,280087,173592,280088,173594,173595,173596,173597,173598,173599,280089,280090,280091,280092,280093,280094,280095,280096,280097,280098,280099,280100,280101,280102,280103,280104,280105,280106,124472,124473,124474,124475,124477,124478,124479,124480,124481,124482,230976,124484,124485,124486,124487,124488,124489,124483,181828,120812,120814,165481,165482,120815,165483,165484,149102,149103,165485,165486,165487,165488,165489,173697,173698,173699,173700,173701,173706,173707,124556,112681,173713,173714,112682,116375,214683,116379,112688,112689,112691,112692,141002,141003,141004,141005,141006,141007,141008,112693,141010,141011,141012,141013,141014,141015,141016,141017,141018,141019,141020,141021,141022,141023,112696,141025,141026,141027,141028,141029,141030,141031,141033,141034,141036,141037,141038,141039,115958,157437,157438,157439,157440,157441,157442,157443,157444,100101,154421,146898,146900,146901,146902,146903,173863,146905,146906,187612,146907,329527,187613,329528,329529,329530,329531,187614,329532,329533,329534,329535,329536,329539,329538,329537,146910,187616,149323,149324,149325,149326,187617,187618,187619,141151,141152,141153,141154,141156,141157,141158,141159,141160,141161,141162,141163,141165,108412,108413,108414,108415,108416,108417,108418,108419,108420,108421,108422,206727,108423,108424,108425,157585,104597,116669,116670,116671,116674,116675,116676,116677,116678,116679,116683,116684,116685,116686,116687,124144,124145,124146,120109,124147,165866,165867,165868,165869,100334,100335,100336,165873,100338,100339,100340,165877,124150,165878,165879,198649,198650,198651,165884,196763,165881,100342,100343,100344,100345,100347,100348,100349,100350,100351,100352,100353,100354,100355,100356,100357,100358,100359,223248,116752,223250,116754,116755,116756,116753,157720,157721,157722,157723,157724,157725,157726,157727,157728,108580,108581,141355,108588,108589,141358,100399,141360,100401,100402,100403,100404,100405,100406,100407,100408,100409,100410,100411,100412,100413,100414,100415,100416,141368,100418,100419,100420,100421,174154,215133,215134,215135,215136,280673,198754,280672,280671,133233,215213,215214,215215,196770,124149,169793,133392,125207,231730,198965,117054,117060,117061,117063,117064,141641,117066,117067,117068,117065,158032,117076,117077,117081,117082,117084,117085,117086,117087,117088,117089,117090,117091,117092,117093,117094,117095,125282,125284,125288,125287,174442,174441,174437,125286,330087,111137,108944,108945,108946,108947,108948,108949,108950,108951,108952,108953,108954,108955,108956,108957,108958,108959,108960,108961,108962,108963,108964,108965,108966,108967,108968,108969,108970,108971,108972,108973,158126,158127,108976,108977,108978,158131,158132,108979,108975,108974,108981,158137,158138,158139,199098,199095,199096,247254,158148,158149,174553,174554,174555,174556,174557,174558,144796,247255,215538,247256,150010,231965,231969,215599,182864,182865,182870,166520,166522,166523,166524,166525,166526,166527,166528,166529,166530,166531,166532,174731,174735,174736,174737,133778,174738,174743,174744,117403,117404,117405,117406,117407,117408,117409,117410,117411,117412,117413,117414,117415,117416,117417,117418,117419,117420,117421,117422,117423,117424,117425,117426,117427,117428,117429,117430,117431,117432,117433,117434,117435,117436,117437,117438,117439,142014,166604,101076,101077,101078,101080,101081,101082,101083,101084,101085,101086,101087,101088,101089,101090,101091,101092,101093,101094,101095,101096,101097,101098,101099,101103,101104,101106,101107,101108,101109,101110,133879,101111,133881,133882,133883,133884,133880,133886,133887,133888,133889,133890,133891,101147,101148,101149,101150,101151,101152,101153,101154,101155,101156,101157,199457,101161,101164,101165,101166,101167,101168,101169,101170,101171,101172,101173,101174,101175,101176,101177,101178,101179,101181,101182,101183,101184,101185,101186,101187,101188,101189,101190,101191,101192,101193,174922,174923,174924,174925,101194,101195,101196,101197,101199,101198,134001,134002,134003,166797,166798,166799,166800,166802,166803,166804,166808,166809,
#166810,166811,166812,166813,166814,166815,109692,117721,117722,117723,117724,117725,117726,117727,117728,117729,117730,117731,117732,117733,117734,117735,117736,150505,150506,183274,175080,183275,183276,183279,134127,183281,134128,134129,134130,134131,134134,134132,134133,109564,109566,109567,109568,109569,109570,109571,109572,109574,109575,109576,109577,109578,109579,109580,109581,109582,109583,109584,109585,109586,109587,109588,109589,109590,109593,109594,109595,109596,109597,109598,109599,109600,109601,109602,109603,109607,142388,142389,142390,142391,126010,142395,142396,142397,126011,224322,224323,224324,224325,224329,224330,109672,109673,109674,109675,101484,101485,101486,101487,101488,109676,109677,109678,109679,109680,109682,109683,109684,109685,109686,109691,109687,109693,109694,109688,109689,109690,109696,109697,101508,109701,109702,109703,109704,109698,147187,147188,147189,147190,147191,126196,126197,126198,126199,126200,126201,126202,126203,126204,126205,126206,126207,126208,126210,126211,126212,126213,126214,126215,126216,126219,126221,126223,126227,126228,106501,106502,106503,106505,159028,159029,159032,159033,159034,159035,132560,106509,132561,106510,132562,106511,132563,132564,132565,200031,132567,142692,142693,142694,142695,142696,142697,142698,142699,142700,132569,142702,142703,142704,132570,106519,132571,134549,134550,134551,134552,134553,134554,134555,134556,109981,109980,109979,109977,134561,134562,134563,134564,134565,109989,109990,109987,109993,109994,109995,109996,109988,109998,109999,110000,110001,110002,134580,134581,134582,134583,118226,249299,118228,118229,118230,118231,118232,118233,118234,118235,175580,118237,101854,118239,118240,118241,175586,118238,118236,175591,101903,101905,101912,101913,101914,101915,101916,101917,101918,101919,101920,101923,101926,126503,126506,140748,126532,126533,126534,126535,126536,126537,126538,126539,126540,126541,126542,126543,126545,126546,126547,126548,126549,126550,102042,102043,192163,159409,159410,183989,183990,183991,183992,183993,183994,183995,183996,224956,183998,183999,151233,241386,167675,167676,126728,200472,200486,99798,175932,184137,184139,184140,233291,184143,159567,167781,126823,126824,126825,110445,167790,110446,110447,110448,110449,110450,110461,110462,110463,110464,110465,110466,110467,110468,110469,118670,118671,118672,118673,118674,118675,118676,118677,118678,118680,118681,118682,118683,118684,118685,118686,118687,118688,118689,118690,118691,118692,118693,118694,118695,118696,118697,118698,126925,126926,258064,258065,258066,258067,258068,258069,110687,110688,110689,168034,110691,110690,168037,110694,168039,110696,168041,168040,110695,110700,110701,110702,110703,110704,110705,110706,110707,230646,110714,110715,110716,110717,110718,110719,110720,110721,110722,110723,110724,110725,110726,110727,110728,110729,110730,110731,102538,110733,110734,110735,110736,110737,110738,110739,102547,102548,102546,102542,102543,102544,102545,102549,102556,102550,106680,102558,102559,102552,102553,106681,102555,102557,102561,102562,106682,102565,102566,102567,102568,106683,102574,102575,102573,102577,102578,102579,106684,102581,102582,102583,102584,102585,102586,102587,106686,102580,106685,106687,176325,176326,106688,111576,225496,225497,225499,111579,135437,135438,135439,135440,135441,135443,192823,192824,192825,192827,110937,109974,110940,127328,127329,127330,127331,109975,109976,127337,127338,127341,127353,127354,127355,127356,127357,127358,127359,127360,127361,127362,127364,127365,127366,127368,109985,109986,176547,176549,250281,242095,119236,119237,127458,127459,127460,201209,183277,102914,102915,193031,193032,193033,193034,193035,193037,193038,193041,193042,193043,193044,193045,193046,193047,193048,217628,217629,217630,217631,217632,217633,217634,217635,111138,111139,111140,217639,111141,217641,139323,111142,111143,160315,160316,176707,184912,139332,168557,168559,168560,168561,168562,168563,168564,168570,168572,168573,168574,103039,103040,103041,103042,103043,103044,103045,103046,103048,103049,111252,111254,111255,111256,111257,111258,111259,111260,111261,
#111262,111263,111264,111266,111267,111269,111270,111271,111272,111273,103088,103089,103090,103091,103092,103093,103094,103095,103096,201404,201405,144076,193247,168682,127730,127731,127732,127733,127734,127735,127736,127737,127738,127739,127740,127741,214264,127745,127746,127747,127749,103174,103175,103176,103177,103178,103179,103180,103181,103182,103183,103184,103185,103186,103187,103188,103189,209699,209700,226085,226086,209702,209704,226089,226090,226091,226092,226087,181710,181711,103228,103229,103230,181712,136000,103231,103232,103234,181713,103235,103236,103237,103238,103239,111439,152414,152417,129617,173582,136077,118227,136083,136084,152481,152483,136100,136101,160679,160680,119727,119728,119729,119730,119731,119732,119733,119734,119736,119737,119738,119739,119740,177099,168909,201680,111572,111573,111574,175229,127958,111577,111578,111575,111580,111581,111582,111583,111584,111585,111586,111587,111588,201716,201717,201718,100337,152570,152571,152572,152573,152574,100341,234516,201748,185369,185370,136220,136221,100346,228799,119880,119884,234581,201820,111709,152669,100360,100361,100362,119933,119934,119935,119936,119937,119938,119939,97109,119940,119944,119945,119946,119947,119948,119949,119950,119951,119952,119953,119954,119955,119956,160917,119957,119958,97113,119959,218266,218267,218268,218269,134566,136380,136381,136382,136383,136384,136385,136386,97122,152775,185563,185564,177376,177377,177378,177379,177380,177381,177383,177384,177386,120043,103660,103661,103662,103663,103664,103665,120050,103667,103666,120051,120045,120047,120048,120049,120052,120059,120060,120053,120062,120054,120055,120056,120057,120058,120063,120064,128262,128259,128258,128265,128266,128267,128268,128269,111886,111887,111888,128264,111890,111891,111892,161045,111894,111895,111896,111897,111893,111899,111900,111901,111902,111903,111904,111905,111898,111906,111908,111909,111910,111911,111912,111913,111914,120107,120108,169261,120110,120111,120112,120113,120114,120115,120116,120117,120118,120119,111919,111920,100400,128317,128318,128319,128320,128321,128322,128323,128324,128325,128326,128327,128328,128329,128330,243014,128332,128333,128334,128335,128336,128337,104420,103668,103669,181824,226676,103672,112005,108980,144784,144785,144786,144787,144788,144789,144790,144791,144792,161175,144794,144795,144793,144797,144798,144799,144800,144801,144802,144803,144804,144805,144806,144807,144808,144809,144810,144811,161219,153030,103942,144913,169539,169540,169541,169542,169543,169544,169545,169546,169547,185956,128618,112259,112260,112261,112263,112265,112266,112267,112268,104077,104078,104079,104080,104081,104082,104083,104084,112270,112269,194192,112273,104089,112274,112276,112275,145074,186046,136904,136905,136906,104139,136908,104141,104142,104143,104144,111880,104146,104148,104149,111881,104152,104153,104154,104155,104156,104157,104158,104159,111883,111882,111884,235242,111885,136947,136948,111889,113520,120616,120617,120619,120620,120623,120624,120625,330083,330084,210753,169794,169795,120044,169797,169798,169799,169796,169801,169800,330085,330086,120046,145232,145233,145234,111907,104283,161640,161641,124939,107030,111915,111916,111918,137116,137117,137118,137119,162399,243665,243667,120796,104413,120798,186832,104414,104415,137186,137187,120804,120805,120806,120807,120808,120809,120810,120811,129004,129005,129006,129007,129008,129009,129010,129011,120819,129013,120818,120817,120816,186836,129018,104434,104435,104436,104437,104438,104439,104449,104450,104451,104452,104453,104454,104446,104447,104448,104458,104459,104460,104461,104457,104463,104464,104456,104465,243727,112660,243728,186842,243729,112670,112671,112672,112673,112674,112675,104484,112676,112677,112678,112679,104489,104490,104491,104492,112680,104494,104495,104496,104497,104498,104499,104500,104501,104502,104503,104504,104505,104506,186425,186426,104509,112695,112694,112698,235585,112697,186427,186834,186835,161907,104575,104576,104577,104578,104579,104580,104581,104582,104583,104584,104585,104586,104587,104588,104589,104590,104591,104592,104593,104594,104595,104596,128251,
#104598,104599,104600,104601,128253,129179,129180,129181,128254,128255,112806,112807,112808,112809,112810,112811,186536,112813,186537,112815,128257,128256,112812,107093,128260,178369,128261,107094,107096,107097,97328,107098,97329,104455,97330,186589,97332,97333,97334,97335,129277,129278,129279,129280,129281,129283,129284,129285,129287,107108,204802,107109,107110,107111,107112,129312,107113,107114,107116,107117,107118,107119,107120,107121,107122,107123,107124,178523,178524,178525,178526,178527,178528,178529,107126,107125,178532,178533,107127,107132,107133,107134,107135,203159,162211,107140,211381,107144,113087,113088,113089,113090,113091,113092,113093,113094,113095,107146,113097,113098,113099,113100,113101,113102,113103,293328,293329,293330,113104,113105,113109,113106,113111,113112,113107,113108,113110,186843,186844,186841,186838,186839,186840,186846,186847,170467,145906,145907,145908,145910,145911,162329,162330,162331,162332,141356,141359,141361,141362,141363,141364,141365,129616,141366,129618,129619,129620,129621,129622,129623,129624,129625,129626,129627,141367,129631,129632,129633,129634,129635,129636,129637,129638,129639,129640,129641,129642,129643,129644,129645,96879,96880,96881,96882,96883,96884,96885,96886,96887,96888,96889,96890,96891,96892,96893,96894,96896,96897,146069,146070,146071,146072,178841,178840,146075,146076,178839,146078,162462,162463,162464,162465,162466,162467,162469,162470,162471,178848,162473,162472,244414,186837,236250,96990,96991,96992,96993,96994,96995,96996,96997,96998,96999,97000,97001,97002,97003,97004,97005,97006,97007,97008,97009,97010,97011,97012,97013,97014,97015,97016,97017,97018,97019,97020,97021,97022,97023,97024,97025,97026,97027,97028,97029,97030,97031,97032,97033,97034,97035,97036,97037,97038,97039,97040,97041,97042,97043,97044,97045,196765,97046,97047,97048,97049,97050,97051,97052,97053,97054,97055,97056,97057,97058,97059,97060,97062,97063,97064,97065,97066,97067,97068,97069,97070,97071,97072,97073,203570,97074,97075,97076,97077,154422,97078,154425,154424,97079,97080,97081,97082,97083,97084,97085,97086,97087,97088,97089,97090,97091,97092,97093,97097,154443,154444,97094,97095,97096,97098,97099,97103,97100,97101,97102,97104,97108,97105,97106,97107,97110,97111,97114,97112,97115,97117,97118,97116,97119,97120,97121,97123,97124,97125,97126,97127,97128,97129,97130,97131,97132,97133,97134,97135,97136,97137,97138,97139,97140,97141,97142,121722,113529,121723,113532,113533,123520,123521,121771,121772,121773,121774,121775,121776,121777,121778,121779,195509,154590,113694,113695,113696,138274,138275,138276,138277,138278,97315,97316,138281,97317,131691,97318,97319,97320,97321,131692,97322,97323,97324,97325,131693,97326,97327,97336,97337,97338,97339,97331,97341,97342,97343,97344,97345,97346,97340,131696,131695,131697,146538,146539,146541,130162,130163,152873,171130,97403,171131,171132,171133,171134,171136,171135,171137,171139,171138,212134,212135,212136,212137,212138,212139,212142,187594,130251,130253,130254,130255,130257,130259,122069,122070,122071,122072,97497,97498,97499,97500,97501,97502,97503,97504,97505,97506,97507,97508,187621,97509,97510,97511,97512,97513,97514,97515,97516,97517,97518,97519,97520,171250,97521,97522,97523,97524,97525,97526,97527,97528,97529,97530,97531,97532,97533,138496,97537,138497,138498,138499,138500,138502,138503,138504,138505,138507,97560,130364,130365,130366,130369,130370,130371,187755,187757,195955,212340,99618,228757,178982,130460,130461,130463,130464,130465,130466,99619,97991,130469,130470,130471,130472,130473,130474,130475,130480,130481,130482,130483,130484,130485,130486,130487,97720,97721,97722,97716,97724,97725,97717,97718,97728,97729,97730,97731,97732,97733,97734,97735,97736,97737,97738,97739,97740,97741,97742,97743,97744,97745,97746,97747,97748,146897,97750,97751,97752,97753,97754,97755,97756,97757,97758,97759,97760,146911,146914,146915,146916,146917,146918,146919,146920,146921,146922,146923,146924,146925,146926,146927,146928,146929,146930,146931,146932,146933,171515,171516,130588,125278,125279,253480,253481,253482,253483,125280,253484,253485,253486,253487,
#125281,253488,125283,125285,122442,114304,114305,114306,114307,114308,114309,114310,114311,169262,169263,97968,97969,97971,97972,97973,97974,97975,97976,97977,97978,97979,97980,97981,97982,97983,97984,97985,97986,97987,97988,97990,114375,114376,114377,97994,97995,97996,97997,97998,114383,97999,97992,98000,98001,130797,130798,130800,130801,122610,122611,122612,163573,163574,163575,130802,163576,163578,163579,163580,163581,163582,163583,163577,147192,122073,122074,102536,122075,102537,102539,245565,102540,122079,147267,102541,122080,180041,122081,122082,122083,122712,122713,122714,122711,106347,106348,106349,106350,106351,106352,106353,106354,122089,102551,110692,110693,102554,188310,155543,155544,155545,155546,163736,155548,147361,147362,147363,147364,161176,147366,147367,147368,147369,147370,147371,147372,147374,147375,147376,98243,98244,122819,102569,102570,106458,106459,106460,102571,106461,102572,155618,155619,155620,155621,163820,163821,114676,102576,204794]
			#out.new.gam
			rep_bubbles = []
			#for line in open('rep_bubbles_35.x.txt'):
			#	var= line.rstrip().split(",")
			#	for i in var:
			#		rep_bubbles.append(int(i))
			#cyclic_bubbles = [98306,98307,98308,98309,98310,98311,98312,98313,98314,98315,98316,98317,98318,98319,98320,98321,98322,98323,98324,98325,98326,98327,98328,98329,98330,98331,98332,98333,98334,98335,98336,98337,98338,98339,98340,98341,98342,98343,98344,98345,98346,98347,98348,98349,98350,98351,98352,98353,98354,98355,98356,98357,98358,98359,98360,98361,98362,98363,98364,98365,98366,98367,98368,98369,139323,155710,139332,139333,131142,139335,131143,131141,131146,131147,131145,131148,131144,98384,98385,98386,98387,98388,98389,98390,98391,98392,98397,98398,98399,98400,98401,98402,98403,98404,98405,98406,98407,98408,98411,98412,98413,110741,110742,110743,110744,180350,110745,110746,110747,110748,98454,98455,98456,98457,98458,98459,98460,98461,98462,98463,98464,98465,98466,98467,98468,98469,245926,98471,98472,98473,98474,98475,98476,245927,98470,98479,98480,98481,98482,98483,98484,98485,98486,98487,98488,98489,98490,98491,98492,98493,98494,98495,98496,98497,98498,98499,98500,98501,98502,98503,98504,98505,98506,98573,98574,98575,98579,131349,131350,131352,131353,131355,131356,139549,303390,303391,303392,303393,303394,303395,196914,107145,188745,262478,262479,262480,262481,98643,98644,98645,98647,98648,98649,98650,98651,98652,98653,98654,98655,98656,98657,98658,98659,107147,198650,221567,98689,98690,198651,229799,110732,229843,229844,106967,106968,106969,106970,106971,106972,106973,106974,106975,106976,106977,106978,106980,98818,98819,98820,98821,98822,98823,98824,98825,98826,98827,98828,98829,98830,98831,139785,139787,98833,98832,139798,139799,139800,139801,139802,98838,139804,139805,139806,107030,107031,180769,180770,180771,180773,180774,205351,180776,205352,180778,180779,180781,148016,189008,107093,107094,107095,107096,107097,107098,98907,98908,98901,98910,98911,98912,98913,98914,98915,98916,98917,107110,107111,107112,107113,107114,115307,115308,115309,115310,115311,115312,115313,115314,115315,115316,115317,115318,115319,131698,107129,107130,107131,115324,115325,115326,115327,115328,115329,115330,115331,115332,115333,115334,107143,115336,115337,115335,115339,107142,107140,107141,107151,107152,107153,107154,107155,107156,107157,107158,107159,107160,107161,107162,107163,107164,107165,107166,107167,107168,107169,107170,107171,213697,213698,148181,148182,148183,148184,140024,107297,107298,107299,107300,107301,107302,107304,223229,223230,205623,205624,205625,223231,222028,222029,110749,189291,131956,131957,131958,131959,110750,131963,131964,131965,222079,249299,158126,158127,140232,246737,107503,107504,156667,156668,156669,107526,107527,107528,107529,107530,107531,107532,107533,107534,115727,115728,115729,132111,214037,174429,181279,104416,181281,181280,174430,174431,164904,104418,174432,104419,174433,255027,255028,255029,255030,255031,255032,255033,104421,255035,255036,255034,104422,174435,174436,104423,174437,104424,174438,104425,104426,104427,123992,123993,123991,104428,123997,104429,189550,130484,130485,164995,246923,222362,238752,173221,104443,104444,337069,337070,337071,104445,197818,197820,197821,165053,165054,197822,165058,244478,293328,124129,124130,124131,124132,124133,124134,124135,124136,124137,124138,124139,124140,124141,124142,124143,124144,124145,124146,124147,124148,115952,124150,124151,230646,115961,115962,115963,115955,115956,115957,115958,115959,115960,115964,115965,115966,115967,115968,115970,99615,99616,214306,214307,214308,214309,214310,99621,214312,214313,214314,99626,99619,99624,99623,99622,156977,99638,99639,99640,99641,99642,99643,99644,99645,99648,99649,99650,99651,99653,99654,99655,99656,99657,99658,99659,99660,99661,99663,99664,99665,99666,329045,329046,230775,104491,173467,104492,116130,171250,104493,171251,116140,116141,116142,116143,116144,116145,104496,116146,116147,116149,116148,116151,116152,116153,116154,116155,104498,116156,116158,116157,206278,198088,198089,198090,140747,140748,140749,99790,99791,132560,132561,132562,132563,181711,181710,181713,181712,99794,132569,132570,132571,99803,124381,99802,124383,99801,124385,124386,124387,124382,124384,104506,104505,173575,280075,280076,280077,
#280078,280079,280080,280081,280082,280083,280084,280085,280086,280087,280088,280089,280090,280091,280092,280093,280094,280095,280096,280097,280098,280099,280100,280101,280102,280103,280104,280105,280106,124472,124473,124474,124475,124477,124478,124479,230976,124481,124482,124480,124484,124485,124486,124487,124488,124489,124483,181828,165481,165482,165483,165484,165485,168034,165486,165487,165488,165489,149102,149103,173697,173698,173699,173700,173701,173706,173707,124556,168041,173713,173714,116375,214683,116379,141002,141003,141004,141005,141006,141007,141008,141010,141011,141012,112695,141014,141015,141016,141017,141018,141019,141020,115953,141013,141023,141022,141025,141026,141027,141028,141029,141030,141031,115954,141033,141034,141036,141037,141038,141039,157437,157438,157439,157440,157441,157442,157443,157444,100101,154421,146898,146900,146901,146902,154422,146903,173863,146905,146906,187612,146907,329527,187613,154423,329530,146908,329532,329533,329534,329535,329536,329537,329538,329539,329531,146910,149323,149324,149325,149326,154424,129004,141151,141152,141153,141154,129005,141156,141157,129006,141159,141160,141161,154425,141163,141162,129007,141165,141158,129008,129009,129010,108412,108413,108414,129011,108415,108416,108417,108418,108420,108421,108422,206727,108423,129013,108424,108425,108419,157585,129018,116669,116670,116671,116674,116675,116676,116677,116678,116679,116683,116684,116685,116686,116687,196763,120109,165866,165867,165868,165869,100334,100335,100336,165873,100338,100339,100340,100341,100342,100343,100344,100345,198649,100347,100348,100349,100350,100351,223232,223233,100352,100353,100354,100355,100356,100357,100359,100360,100361,100362,124939,100358,223248,116752,116754,116755,116756,116753,223250,196764,157720,157721,157722,157723,157724,157725,157726,157727,157728,108580,108581,141355,141356,108589,141358,141359,141360,141361,141362,141363,141364,141365,141366,141367,141368,111137,100401,100402,100403,100404,100414,100415,100416,100408,100409,100410,100411,100412,100413,100421,100420,100419,174154,100418,215133,215134,280671,280672,280673,198754,215135,215136,133233,128251,194192,215213,215214,215215,196770,124149,196765,133392,125207,99787,99788,99789,154443,231730,198965,117054,99792,99793,117060,117061,117063,117064,141641,117065,117066,117067,117068,154444,158032,99796,117076,117077,99797,117081,117082,117084,117085,117086,117087,117088,117089,117090,117091,117092,117093,117094,117095,125285,125286,125284,125287,125288,99800,330087,330086,174442,174441,99804,108944,108945,108946,108947,108948,108949,108950,108951,108952,108953,108954,108955,108956,108957,108958,108959,108960,108961,108962,108963,108964,108965,108966,108967,108968,108969,108970,108971,108972,108973,108974,108975,108976,108977,108978,108979,158132,108981,158131,199095,199096,158137,199098,158139,158138,108980,247254,158148,158149,174553,174554,174555,144796,174556,174557,174558,247255,215538,247256,150010,231965,231969,215599,100399,182864,182865,182870,166520,166522,166523,166524,166525,166526,166527,166528,166529,166530,166531,166532,101485,101486,174731,174735,174736,174737,174738,133778,101487,101488,174743,174744,117403,117404,117405,117406,117407,117408,117409,117410,117411,117412,117413,117414,117415,117416,117417,117418,117419,117420,117421,117422,117423,117424,117425,117426,117427,117428,117429,117430,117431,117432,117433,117434,117435,117436,117437,142014,117439,117438,166604,101076,101077,101078,101080,101081,101082,101083,101084,101085,101086,101087,101088,101089,101090,101091,101092,101093,101094,101095,101096,101097,101098,101099,101103,101104,101106,101107,101108,101109,101110,101111,133879,133880,133881,133882,133883,133884,133886,133887,133888,133889,133890,133891,101147,101148,101149,101150,101151,101152,101153,101154,101155,101156,101157,199457,101161,101164,101165,101166,101167,101168,101169,101170,101171,101172,101173,101174,101175,101176,101177,101178,101179,101181,101182,101183,101184,101185,101186,101187,101188,101189,101190,101191,101192,101193,101194,101195,101196,101197,101198,101199,174925,174924,
#174922,174923,134001,134002,134003,166797,166798,166799,166800,166802,166803,166804,166808,166809,166810,166811,166812,166813,166814,166815,117721,117722,117723,117724,117725,117726,117727,117728,117729,117730,117731,117732,117733,117734,117735,117736,150505,183274,150506,175080,183276,183275,183279,134127,183281,134128,134129,134130,134131,134134,134132,134133,109564,109566,109567,109568,109569,109570,109571,109572,109574,109575,109576,109577,109578,109579,109580,109581,109582,109583,109584,109585,109586,109587,109588,109589,109590,109593,109594,109595,109596,109597,109598,109599,109600,109601,109602,109603,109607,142388,142389,142390,142391,126010,126011,142395,142396,142397,224322,224323,224324,224325,224329,224330,329528,329529,106682,109672,109673,109674,109675,109676,109677,109678,109679,109680,101484,109682,109683,109684,109685,109686,109687,109688,109689,109690,109691,109692,175229,109693,109694,109696,109697,109698,101508,109701,109702,109703,109704,147187,147188,147189,147190,147191,126196,126197,126198,126199,126200,126201,126202,126203,126204,126205,126206,126207,126208,126210,126211,126212,126213,126214,126215,126216,126219,126221,126223,126227,126228,106501,106502,106503,106505,159028,159029,159032,159033,159034,159035,131690,106509,106510,106511,98370,132564,131691,132565,200031,132567,142692,142693,142694,142695,142696,142697,142698,142699,142700,142702,142703,142704,131692,106519,132572,165884,131693,134549,109974,109975,109976,109977,134554,109979,109980,109981,134553,134552,134556,109985,109986,109987,109988,109989,109990,134565,134564,109993,109994,109995,109996,134566,109998,109999,110000,110001,110002,134580,134581,134582,134583,118226,118227,118228,118229,118230,118231,118232,118233,118234,118235,175580,118237,101854,118239,118240,118241,175586,118238,118236,175591,210753,101903,101905,101912,101913,101914,101915,101916,101917,101918,101919,101920,101923,101926,126503,126506,126532,126533,126534,126535,126536,126537,126538,126539,126540,126541,126542,126543,126545,126546,126547,126548,126549,126550,102042,102043,192163,159409,159410,183989,183990,183991,183992,183993,183994,183995,183996,224956,183998,183999,151233,241386,167675,167676,126728,200472,200486,99798,175932,184137,184139,184140,99799,233291,159567,184143,167781,126823,126824,126825,110445,167790,110446,110447,110448,110449,110450,110461,110462,110463,110464,110465,110466,110467,110468,110469,118670,118671,118672,118673,118674,118675,118676,118677,118678,118680,118681,118682,118683,118684,118685,118686,118687,118688,118689,118690,118691,118692,118693,118694,118695,118696,118697,118698,126925,126926,258064,258065,258066,258067,258068,258069,110687,110688,110689,110690,110691,110692,110693,110694,110695,110696,168037,168039,168040,110700,110701,110702,110703,110704,110705,110706,110707,110714,110715,110716,110717,110718,110719,110720,110721,110722,110723,110724,110725,110726,110727,110728,110729,110730,110731,102536,110733,110734,110735,110736,110737,110738,110739,102539,102540,102541,102542,102543,102544,102545,102546,102547,143517,102549,102550,102551,102552,102553,102554,102555,102556,102557,102558,102559,102561,102562,102565,102566,102573,102567,102575,102576,102577,102578,102579,102580,102581,102582,102583,102584,102585,102586,102587,106685,106686,106687,176325,176326,106688,225496,225497,225499,111579,135437,135438,135439,135440,135441,135443,192823,192824,192825,192827,131140,110937,110940,127328,127329,127330,127331,127337,127338,127341,127353,127354,127355,127356,127357,127358,127359,127360,127361,127362,127364,127365,127366,127368,176547,176549,250281,242095,119236,119237,127458,127459,127460,201209,183277,102914,102915,193031,193032,193033,193034,193035,193037,193038,193041,193042,193043,193044,193045,193046,193047,193048,217628,217629,217630,217631,217632,217633,217634,217635,111138,111139,111140,111141,111142,111143,217639,217641,160315,160316,176707,184912,168557,168559,168560,168561,168562,168563,168564,168570,168572,168573,168574,103039,103040,103041,103042,103043,103044,103045,103046,103048,103049,111252,111254,111255,
#111256,111257,111258,111259,111260,111261,111262,111263,111264,111266,111267,111269,111270,111271,111272,111273,103088,103089,103090,103091,103092,103093,103094,103095,103096,201404,201405,144076,193247,168682,127730,127731,127732,127733,127734,127735,127736,127737,127738,127739,127740,127741,214264,127745,127746,127747,127749,103174,103175,103176,103177,103178,103179,103180,103181,103182,103183,103184,103185,103186,103187,103188,103189,209699,209700,226085,226086,226087,209704,226089,226090,226091,226092,209702,103228,103229,103230,103231,103232,136000,103234,103235,103236,103237,103238,103239,111439,152414,152417,173582,106680,141021,136077,136083,136084,106681,97063,152481,152483,136100,136101,160679,160680,173592,119727,119728,119729,119730,119731,119732,119733,119734,173594,119736,119737,119738,119739,119740,173595,173596,173597,173598,106683,177099,173599,168909,201680,111572,111573,111574,127958,111575,111577,111578,111576,111580,111581,111582,111583,111584,111585,111586,111587,111588,106684,201716,100337,201717,201718,152570,152571,152572,152573,152574,234516,201748,185369,185370,136220,136221,100346,97094,119880,119884,234581,134550,201820,111709,152669,111708,134551,134555,119933,119934,119935,119936,119937,119938,119939,119940,119944,119945,119946,119947,119948,119949,119950,119951,119952,119953,119954,119955,119956,119957,119958,119959,160917,134562,134561,218267,218268,134563,218266,218269,99620,136380,136381,136382,136383,136384,136385,136386,152775,185563,185564,177376,177377,177378,177379,177380,177381,177383,177384,177386,120043,103660,103661,103662,103663,103664,103665,103666,103667,120047,120048,120049,120050,120051,120052,120053,120054,120055,120056,120057,120058,120059,120060,120063,128259,128258,128257,128262,128256,111880,111881,111882,111883,111884,111885,111886,111887,111888,111889,111890,111891,128269,111893,111894,111895,111896,111897,111898,111899,111900,111901,111902,111903,111904,111905,111906,111907,111908,111909,111910,111911,111912,111913,111914,120107,120108,169261,120110,120111,120112,120113,120114,120115,120116,120117,120118,120119,111919,111920,100400,128317,128318,128319,128320,128321,128322,128323,128324,128325,128326,128327,128328,128329,128330,243014,128332,128333,128334,128335,128336,128337,100405,100406,100407,103668,103669,181824,226676,103672,112005,144784,144785,144786,144787,144788,144789,144790,144791,144792,144793,144794,144795,161175,144797,144798,144799,144800,144801,144802,144803,144804,144805,144806,144807,144808,144809,144810,144811,174434,161219,153030,103942,144913,108588,169539,169540,169541,169542,169543,169544,169545,169546,169547,185956,128618,112259,112260,112261,112263,112265,112266,112267,112268,104077,104078,104079,104080,104081,104082,104083,104084,112273,112274,112276,112275,104089,145074,186046,136904,136905,136906,104139,136908,104141,104142,104143,104144,104146,104148,104149,104152,104153,104154,104155,104156,104157,104158,104159,235242,136947,136948,111892,120616,120617,120619,120620,120623,120624,120625,330083,330084,169793,169794,169795,169796,169797,169798,169799,169800,169801,120044,120045,330085,120046,145232,145233,145234,104283,161640,161641,111915,111916,111918,137116,137117,120062,137119,137118,120064,162399,98902,98904,98905,243665,243667,98906,98909,120796,104413,120798,104414,104415,104417,137186,137187,120804,120805,120806,120807,120808,120809,120810,120811,120812,104420,104430,104431,104432,120817,120818,120819,120816,120815,120814,104433,104434,104435,104436,104437,104438,104439,104440,104441,104442,104449,104450,104451,104452,104453,104454,104446,104447,104448,104458,104459,104460,104461,104457,104463,104464,104465,186832,243727,112660,243728,243729,112670,112671,112672,112673,112674,112675,112676,112677,112678,112679,112680,112681,112682,104484,104489,104490,104494,104495,112688,112689,104497,112691,112692,112693,112694,104501,112696,112697,112698,104500,104499,104509,104503,104502,186427,186426,186425,235585,186834,186835,161907,186836,104575,104576,104577,104578,104579,104580,104581,104582,104583,104584,104585,104586,104587,104588,
#104589,104590,104591,104592,104593,104594,104595,104596,104597,104598,104599,104600,104601,128253,129179,129180,129181,128254,128255,112806,112807,186838,186537,186536,112808,112809,112810,112811,112815,112812,112813,128260,178369,128261,128264,128265,104455,128266,186589,128267,128268,104456,129277,129278,129279,129280,129281,129283,129284,129285,129287,107108,204802,107109,129312,107116,107117,107118,107119,107120,107121,107122,107123,107124,178523,178524,107125,178525,178526,178527,178529,107126,178528,178532,178533,107127,107128,107132,107133,107134,107135,293329,203159,162211,293330,211381,107144,113087,113088,113089,113090,113091,113092,113093,113094,113095,107146,113097,113098,113099,113100,113101,113102,113103,113104,113105,113106,113107,113108,113109,113110,113111,113112,107149,107148,107150,186840,186839,186846,186847,186841,186844,186843,186842,170467,145906,145907,145908,145910,145911,162329,162330,162331,162332,129616,129617,129618,129619,129620,129621,129622,129623,129624,129625,129626,129627,129631,129632,129633,129634,129635,129636,129637,129638,129639,129640,129641,129642,129643,129644,129645,96879,96880,96881,96882,96883,96884,96885,96886,96887,96888,96889,96890,96891,96892,96893,96894,96896,96897,146069,146070,146071,178840,178841,146072,146075,146076,178839,162462,162463,162464,162465,178848,162467,146078,162469,162470,162471,162466,162473,162472,244414,186837,236250,96990,96991,96992,96993,96994,96995,96996,96997,96998,96999,97000,97001,97002,97003,97004,97005,97006,97007,97008,97009,97010,97011,97012,97013,97014,97015,97016,97017,97018,97019,97020,97021,97022,97023,97024,97025,97026,97027,97028,97029,97030,97031,97032,97033,97034,97035,97036,97037,97038,97039,97040,97041,97042,97043,97044,97045,97046,97047,97048,97049,97050,97051,97052,97053,97054,97055,97056,97057,97058,97059,97060,196767,178982,97062,97064,97065,97066,97067,97068,97069,97070,97071,97072,97073,97074,203570,97075,97077,97078,97079,97080,97081,97082,97083,97076,97084,97085,97087,97088,97089,97090,97091,97092,97093,97086,97095,97096,97097,97098,97099,97100,97101,97102,97103,97104,97105,97106,97107,97108,97109,97110,97111,97112,97113,97114,97115,97116,97117,97118,97119,97120,97121,97122,97123,97124,97125,97126,97127,97128,97129,97130,97131,97132,97133,97134,97135,97136,97137,97138,97139,97140,97141,97142,113520,113529,121722,121723,113532,113533,123520,123521,121771,121772,121773,121774,121775,121776,121777,121778,121779,195509,154590,165877,165878,131686,165879,131687,131688,165881,113694,113695,113696,131689,138274,97315,97316,97317,97318,97319,97320,97321,97322,97323,97324,97325,97326,97327,97328,97329,97330,97331,97332,97333,97334,97335,97336,97337,97338,97339,97340,97341,97342,97343,97344,97345,97346,131695,131696,131697,146538,97511,146539,146541,97512,130162,130163,97513,152873,97514,97403,171130,171131,171132,97515,171133,171134,171135,171139,97516,171136,171137,171138,97518,212134,212135,212136,212137,212138,212139,212142,187594,130251,130253,130254,130255,130257,130259,122069,122070,122071,122072,97497,97498,97499,97500,97501,97502,97503,97504,97505,97506,97507,97508,97509,97510,187614,187616,187617,187618,187619,187621,122089,97517,97519,97520,97521,97522,97523,97524,97525,97526,97527,97528,97529,97530,97531,97532,97533,138496,97537,138497,138498,138499,138500,138502,138503,138504,138505,138507,161045,97560,130364,130365,130366,130369,130370,130371,187755,187757,195955,212340,99618,138275,228757,138276,138277,130460,130461,130463,138278,130464,97991,130465,130466,130469,130470,130471,130472,104504,130473,130474,130475,138281,130480,130481,130482,130483,97716,97717,97718,130487,97720,97721,97722,97723,97724,97725,130486,228799,97728,97729,97730,97731,97732,97733,97734,97735,97736,97737,97738,97739,97740,97741,97742,97743,97744,97745,97746,97747,97748,146897,97750,97751,97752,97753,97754,97755,97756,97757,97758,97759,97760,146911,146914,146915,146916,146917,146918,146919,146920,146921,146922,146923,146924,146925,146926,146927,146928,146929,146930,146931,146932,146933,171515,171516,130588,125278,125279,253480,253481,253482,
#253483,125280,253484,253485,253486,253487,125281,253488,125282,125283,122442,112269,112270,114304,114305,114306,114307,114308,114309,114310,114311,169262,169263,97968,97969,97971,97972,97973,97974,97975,97976,97977,97978,97979,97980,97981,97982,97983,97984,97985,97986,97987,97988,97990,114375,114376,114377,97994,97995,97996,97997,97998,114383,97999,97992,98000,98001,130797,130798,130800,130801,130802,122611,122612,163573,163574,163575,122610,163576,163578,163579,163580,163581,163582,163583,163577,147192,122073,122074,122075,102537,102538,245565,122079,147267,122080,180041,122081,122082,122083,122711,122712,122713,122714,102548,106347,106348,106349,106350,106351,106352,106353,106354,188310,155543,155544,155545,155546,163736,155548,147361,147362,147363,147364,161176,147366,147367,147368,147369,147370,147371,147372,147374,147375,147376,98243,98244,122819,102568,102569,102570,106458,106459,106460,102571,106461,102572,155618,155619,155621,155620,102574,163820,163821,114676,204794]
			#cyclic_bubbles = [215996,215997,215996,215997,215996,215997,215996,215997,299459,299460,299461,299462,299463,316849,316850,316851,316852,369309,369310,369311,369312,369313,369314,369315,369316,369317,369318,369319,369320,369321,369322,369323,369324,369325,369326,369327,369328,369329,369330,369331,369332,369333,369334,369335,369336,369337,369338,369339,369340,369341,369342,369343,369344,369345,369346,369347,369348,369349,369350,369351,369352,370310,370311,370312,370319,370320,370321,370322,413497,413498,413499,413500,413501,413502,413503,413505,413506,413507,413508,413509,413510,413511,413512,413513,413514,413515,413516,413517,427880,427881,427882,427883,427884,427885,427886,427887,427888,427889,427890,427891,427892,427893,427894,427895,427896,427900,428849,428850,153830,153831,153832,153833,153834,153893,153894,153895,153896,153897,153898,153899,153900,153901,153950,153951,154500,154501,154502,154503,154504,154505,154506,154507,154508,154509,154510,154771,154772,154773,154774,154775,155628,155629,155630,155631,155632,155633,155634,155635,155636,155637,155638,155639,155640,155641,155642,155643,155644,155645,155646,155647,155648,155649,155650,155651,155652,155653,155654,155655,155656,155657,155658,155659,155660,155661,155662,155663,155664,155665,155666,155667,155668,155669,155670,155671,155672,155673,155674,155675,155676,155677,155678,155679,155680,155681,155682,155683,155684,155685,155686,155687,155688,155689,155690,155691,155692,155693,155694,155695,163473,163474,163475,163476,163477,163478,163479,163480,163481,163482,163483,163484,163485,163486,163487,163488,163489,163490,163491,163492,163493,163494,163495,163496,163497,163498,163499,163500,163501,163502,163503,163504,163505,163506,163507,163508,163509,163510,163511,163512,163513,163514,163515,163516,163517,163518,173695,173696,173697,173698,173699,173700,173701,154500,154501,154502,154503,154504,154505,154506,154507,154508,154509,154510,153522,153523,153524,153525,153526,153527,153528,153529,153530,153531,153532,153533,153679,153680,153681,153682,153683,153684,153685,153686,153687,153688,153689,153830,153831,153832,153833,153834,153893,153894,153895,153896,153897,153898,153899,153900,153901,153950,153951,154500,154501,154502,154503,154504,154505,154506,154507,154508,154509,154510,154771,154772,154773,154774,154775,154779,154780,154781,154782,154783,154784,154912,154913,157734,157735,157736,157754,157755,157756,157757,157758,157759,159804,159805,159806,159807,159808,159809,159810,159811,162213,162214,162215,162216,162217,162228,162229,162230,162231,162232,162233,162234,162235,162236,162237,162317,162318,162319,162320,162321,162322,162323,162792,162936,162937,162938,163814,163815,163816,163817,163818,163819,163820,163824,163825,163826,163827,163828,163829,165779,165780,165781,165782,165783,165784,165785,165786,165787,165788,165789,165790,165791,167346,167347,167715,167716,167717,167718,173695,173696,173697,173698,173699,173700,173701,215996,215997,232978,232979,232980,232981,232982,232983,232984,232985,232986,232987,232988,232989,232990,232991,232992,232993,232994,232995,232996,232997,232998,232999,233000,233001,233002,233003,233004,233005,233006,233007,233008,233009,233010,233011,233012,233013,233014,233015,233016,233017,233018,233019,233020,233021,233022,233023,233024,233025,233026,233027,233028,233029,233030,233031,233032,233033,233034,233035,233036,233037,233038,233039,233040,233041,233042,233043,233044,233045,233046,233047,233048,233049,233050,233051,233052,233053,233054,233055,233056,233057,233058,233059,233060,233061,233062,233063,233064,233065,233066,233067,233068,254958,254959,254960,254961,292089,292090,292091,292092,292093,292094,395924,395925,395926,395927,395928,395929,423473,423474,423475,423476,423477,423478,423479,427811,215996,215997,202558,202559,202560,202561,202562,202563,202564,202565,202566,202567,202568,202569,202570,202571,202572,202573,202574,202575,202576,202577,202578,202579,202580,202581,202582,202583,202584,202585,202586,202587,202588,202589,202590,202592,202593,202594,202595,202596,202597,202598,202599,202600,202601,202602,202603,202604,
#202605,202606,202607,205018,205019,205020,253526,325261,327819,327820,327821,327822,327898,327899,327900,327901,327902,327903,327904,327905,384853,394886,394887,394888,394889,394890,394891,424613,424614,424615,424616,424617,424618,424619,424620,193796,215996,215997,163814,163815,163816,163817,163818,163819,163820,165779,165780,165781,165782,165783,165784,165785,165786,165787,165788,167346,167347,341778,341779,341780,201321,201322,201323,201324,201325,201326,201327,201328,201329,201330,201331,201332,201333,201334,201335,201336,201337,201338,201339,201340,201341,201342,201343,201344,201345,201346,201347,201348,174336,174337,174338,215996,215997,163814,163815,163816,163817,163818,163819,163820,165779,165780,165781,165782,165783,165784,165785,165786,165787,165788,167346,167347,341778,341779,341780,162936,162937,162938,163814,163815,163816,163817,163818,165779,165780,165781,165782,165783,165784,165785,165786,165787,165788,165789,165790,165791,167346,167347,341778,341779,341780,202558,202559,202560,202561,202562,202563,202564,202565,202566,202567,202568,202570,202571,202572,202573,202574,202575,202576,202577,202578,202579,202580,202581,202582,202583,202584,202585,202586,202587,202588,202589,202590,202592,202593,202594,202595,202596,202597,202598,202599,202600,202601,202602,202603,202604,202605,202606,202607,205018,205019,205020,325261,327818,424620,215996,215997,215996,215997,160637,160638,160639,160640,160641,160642,160643,160644,160645,160768,162936,162937,162938,165777,165778,165779,165780,165781,165782,165783,165784,165785,165786,165787,165788,165789,165790,165791,341778,341779,341780,255008,255009,255010,255011,255012,255014,255015,255016,255017,255018,255019,255020,255021,255022,255023,255024,255025,255026,255027,255028,255029,255030,255031,255032,255033,255034,255035,255036,255037,255038,255039,255040,255041,255042,255043,255044,255045,255046,255047,255048,255049,255050,255051,255052,255053,255054,255055,255056,255057,255058,255059,255060,255061,255065,255066,255067,255068,255069,330018,330019,330020,330021,330022,330023,330024,330025,330026,330027,330028,330029,330030,355514,355515,355516,361866,361867,361868,361869,361870,361871,377612,377613,377614,377615,377616,255008,255009,255010,255011,255012,255013,255014,255015,255016,255017,255018,255019,255020,255021,255022,255023,255024,255025,255026,255027,255028,255029,255030,255031,255032,255033,255034,255035,255036,255037,255038,255039,255041,255042,255043,255044,255045,255046,255047,255048,255049,255050,255051,255052,255053,255054,255055,255056,255057,255058,255059,255060,255061,255062,255063,255064,255065,255066,255067,255068,255069,255076,255077,255078,255079,330026,330027,330028,330029,355510,355514,355515,361864,361865,361866,361867,361868,361869,361870,361871,377612,377613,377614,377615,377616,409831,409832,409833,412252,412253,412254,432832,432833,432834,215996,215997,255008,255009,255010,255011,255012,255013,255014,255015,255016,255017,255018,255019,255020,255021,255022,255023,255024,255025,255026,255027,255028,255029,255030,255031,255032,255033,255034,255035,255036,255037,255038,255039,255040,255041,255042,255043,255044,255045,255046,255047,255048,255049,255050,255051,255052,255053,255054,255055,255056,255057,255058,255059,255060,255061,255062,255063,255064,255065,255066,255067,255068,255069,255076,255077,255078,255079,330018,330019,330020,330021,330022,330023,330024,330025,330026,330027,330028,330029,330030,355510,355511,355512,355513,355514,355515,355516,361866,361867,361868,361869,361870,361871,377612,377613,377614,377615,377616,409831,409832,409833,412252,412253,412254,432832,432833,432834,215996,215997,193796,153893,153894,153895,153896,153897,153898,153899,153900,153901,157734,157735,157736,157754,157755,157756,157757,157758,157759,159804,159805,159806,159807,159808,159809,159810,159811,162317,162318,162319,162320,162321,162322,162323,167715,167716,167717,167718,393692,393699,393700,255008,255009,255010,255011,255012,255013,255014,255015,255016,255017,255018,255019,255020,255021,255022,255023,255024,255025,255026,255027,255028,255029,255030,255031,255032,
#255033,255034,255035,255036,255037,255038,255039,255040,255041,255042,255043,255044,255045,255046,255047,255048,255049,255050,255051,255052,255053,255054,255055,255056,255057,255058,255059,255060,255061,255062,255063,255064,255065,255066,255067,255068,255069,255070,255071,255072,255073,255074,255075,255076,255077,255078,255079,330018,330019,330020,330021,330022,330023,330024,330025,330026,330027,330028,330029,330030,355510,355511,355512,355513,409831,409832,409833,412252,412253,412254,432832,432833,432834,215996,215997,215996,215997,215996,215997,215996,215997,232978,232979,232980,232981,232982,232983,232984,232985,232986,232987,232988,232989,232990,232991,232992,232993,232994,232995,232996,232997,232998,232999,233000,233001,233002,233003,233004,233005,233006,233007,233008,233009,233010,233011,233012,233013,233014,233015,233016,233017,233018,233019,233020,233021,233022,233023,233024,233025,233026,233027,233028,233029,233030,233031,233032,233033,233034,233035,233036,233037,233038,233039,233040,233041,233042,233043,233044,233045,233046,233047,233048,233049,233050,233051,233052,233053,233054,233055,233056,233057,233058,233059,233060,233061,233062,233063,233064,233065,233066,233067,233068,254958,254959,254960,254961,292089,292090,292091,292092,292093,292094,423473,423474,423475,423476,423477,423478,423479,427811,215996,215997,195975,195976,195977,195978,195979,195980,195981,195982,195983,195984,195985,195986,195987,195988,195989,195990,195991,195992,195993,195994,195995,195996,195997,195998,195999,196000,196001,196002,196003,196004,196005,196006,196007,196008,196009,196010,196011,196012,196013,196014,196015,196016,196017,196018,196019,196020,196021,196022,196023,196024,196025,196026,196027,196028,196029,196030,196031,196035,196036,196037,196038,196039,196040,196041,196042,196043,283640,283641,283642,283643,283644,283645,283646,283647,283648,283649,283650,318222,318223,318224,318225,318226,318227,318228,318229,318230,318231,419751,419752,427927,427928,430223,430224,215996,215997,157734,157735,157736,157754,157755,157756,157757,157758,157759,159804,159805,159806,159807,159808,159809,159810,159811,162213,162214,162215,162216,162217,162228,162229,162230,162231,162232,162233,162234,162235,162236,162237,162317,162318,162319,162320,162321,162322,162323,162792,162936,162937,162938,165779,165780,165781,165782,165783,165784,165785,165786,165787,165788,255008,255009,255010,255011,255012,255014,255015,255016,255017,255018,255019,255020,255021,255022,255023,255024,255025,255026,255027,255028,255029,255030,255031,255032,255033,255034,255035,255036,255037,255038,255039,255040,255041,255042,255043,255044,255045,255046,255047,255048,255049,255050,255051,255052,255053,255054,255055,255056,255057,255058,255059,255060,255061,255062,255063,255064,255065,255066,255067,255068,255069,255076,255077,255078,255079,330026,330027,330028,330029,355510,355511,355512,355513,409831,409832,409833,412252,412253,412254,432832,432833,432834,215996,215997,153522,153523,153524,153525,153526,153527,153528,153529,153530,153531,153532,153533,153679,153680,153681,153682,153683,153684,153685,153686,153687,153688,153689,154779,154780,154781,154782,154783,154784,154912,154913,202558,202559,202560,202561,202562,202563,202564,202565,202566,202567,202568,202569,202570,202571,202572,202573,202574,202575,202576,202577,202578,202579,202580,202581,202582,202583,202584,202585,202586,202587,202588,202589,202590,202592,202593,202594,202595,202596,202597,202598,202599,202600,202601,202602,202603,202604,202605,202606,202607,205019,205020,253526,325261,327818,327819,327820,327821,327822,327898,327899,327900,327901,327902,327903,327904,327905,384853,394886,394887,424613,424614,424615,424616,424617,424618,424619,215996,215997,215996,215997,215996,215997,156957,156958,156959,156960,156961,156962,156963,156964,156965,156966,156967,156968,156969,156970,156971,156972,156973,156974,156975,156976,156977,156978,156979,156980,156981,156982,156983,156984,156985,156986,156987,156988,156989,156990,156991,156992,156993,156994,156995,156996,156997,156998,156999,157000,157001,157002,157003,157004,
#157005,157006,157007,157008,157009,157010,157011,157012,157013,157014,157015,157016,157017,157018,157019,157020,157021,157022,157023,157024,157025,157026,157027,157028,157029,157030,157031,157032,157033,173686,173687,173688,173689,173690,173691,173692,173693,173694,173695,173696,173697,173698,173699,173700,173701,180811,180812,180813,255008,255009,255010,255011,255012,255014,255015,255016,255017,255018,255019,255020,255021,255022,255023,255024,255025,255026,255027,255028,255029,255030,255031,255032,255033,255034,255035,255036,255037,255038,255039,255040,255041,255042,255043,255044,255045,255046,255047,255048,255049,255050,255051,255052,255053,255054,255055,255056,255057,255058,255059,255060,255061,255065,255066,255067,255068,255069,255076,255077,255078,255079,330018,330019,330020,330021,330022,330023,330024,330025,330026,330027,330028,330029,330030,409831,409832,409833,412252,412253,412254,432832,432833,432834,373437,373438,215996,215997,232978,232979,232980,232981,232982,232983,232984,232985,232986,232987,232988,232989,232990,232991,232992,232993,232994,232995,232996,232997,232998,232999,233000,233001,233002,233003,233004,233005,233006,233007,233008,233009,233010,233011,233012,233013,233014,233015,233016,233017,233018,233019,233020,233021,233022,233023,233024,233025,233026,233027,233028,233029,233030,233031,233032,233033,233034,233035,233036,233037,233038,233039,233040,233041,233042,233043,233044,233045,233046,233047,233048,233049,233050,233051,233052,233053,233054,233055,233056,233057,233058,233059,233060,233061,233062,233063,233064,233065,233066,233067,233068,395924,395925,395926,395927,395928,395929,423473,423474,423475,423476,423477,423478,423479,427811,215996,215997,215996,215997,215996,215997,201321,201322,201323,201324,201325,201326,201327,201328,201329,201330,201331,201332,201333,201334,201335,201336,201337,201338,201339,201340,201341,201342,201343,201344,201345,201346,201347,201348,255622,255623,255624,255625,255626,255627,255628,255629,255630,255631,255008,255009,255010,255011,255012,255013,255014,255015,255016,255017,255018,255019,255020,255021,255022,255023,255024,255025,255026,255027,255028,255029,255030,255031,255032,255033,255034,255035,255036,255037,255038,255039,255040,255041,255042,255043,255044,255045,255046,255047,255048,255049,255050,255051,255052,255053,255054,255055,255056,255057,255058,255059,255060,255061,255062,255063,255064,255065,255066,255067,255068,255069,255070,255071,255072,255073,255074,255075,255076,255077,255078,255079,330018,330019,330020,330021,330022,330023,330024,330025,330026,330027,330028,330029,330030,355510,355511,355512,355513,355514,355515,355516,361866,361867,361868,361869,361870,361871,377612,377613,377614,377615,377616,409831,409832,409833,412252,412253,412254,432832,432833,432834,369314,369315,369316,369317,369318,369319,369320,369321,369322,369323,369324,369325,369326,369327,369328,369329,369330,369331,369332,369333,369334,369335,369336,369337,369338,369339,369340,369341,369342,369343,369344,369345,369346,369347,369348,369349,369350,369351,369352,370319,370320,370321,370322,382598,382599,413516,413517,427880,427881,427882,427883,427884,427885,427886,427887,427888,427889,427890,427891,427892,427893,427894,427895,427896,427897,427898,427899,427900,427991,201320,201321,201322,201323,201324,201325,201326,201327,201328,201329,201330,201331,201332,201333,201334,201335,201336,201337,201338,201339,201340,201341,201342,201343,201344,201345,201346,201347,201348,255622,255623,255624,255625,255626,255627,255628,255629,255630,255631,341061,341062,341063,341064,341065,341066,341067,416318,416319,416320,416321,193796]
			#cyclic_bubbles = [102838,102840,102846,102850,52424,52430,52708,52711,54914,54917,60635,60638,60965,60968,61857,61861,61906,61909,65760,65762,67841,67844,67858,67862,70509,70513,73378,73380,83218,83220,83224,83231,83676,83678,86581,86586,92007,92012,92467,92474,97403,97405,99187,99190]
			if l.snarl.end.node_id in cyclic_bubbles or l.snarl.start.node_id in cyclic_bubbles:
				continue
			if l.snarl.end.node_id in cyclic_bubbles1 or l.snarl.start.node_id in cyclic_bubbles1:
				continue
			if l.snarl.end.node_id in rep_bubbles or l.snarl.start.node_id in rep_bubbles:
				continue
			#if l.snarl.end.node_id not in nodes_list and l.snarl.start.node_id not in nodes_list:
			#	continue
			#if l.snarl.start.node_id not in nodes_list:
			#	continue
			if len(l.visits) ==0:
				#TODO: for now, assumed, all nodes in path are either forward or backward
				if l.snarl.start.backward == True:
					path_in_bubble.append(tuple ((l.snarl.end.node_id,l.snarl.start.node_id)))
				else:
					path_in_bubble.append(tuple ((l.snarl.start.node_id,l.snarl.end.node_id)))
			else:
				#TODO: for now, assumed, all nodes in path are either forward or backward
				if l.snarl.start.backward == True:
					path_in_bubble.append(tuple ((l.snarl.end.node_id, l.visits[-1].node_id)))
					for i in range(0,len(l.visits)-1):
						path_in_bubble.append(tuple((l.visits[i+1].node_id, l.visits[i].node_id)))
					path_in_bubble.append(tuple ((l.visits[0].node_id,l.snarl.start.node_id)))
				else:
					path_in_bubble.append(tuple ((l.snarl.start.node_id,l.visits[0].node_id)))
					for i in range(0,len(l.visits)-1):
						path_in_bubble.append(tuple((l.visits[i].node_id, l.visits[i+1].node_id)))
					path_in_bubble.append(tuple ((l.visits[-1].node_id, l.snarl.end.node_id))) 

			if current_startsnarl == prev_startsnarl and current_endsnarl == prev_endsnarl and current_endsnarl_orientation == prev_endsnarl_orientation and prev_startsnarl_orientation == current_startsnarl_orientation:
				per_locus.append(path_in_bubble)
			else:
				locus_count=locus_count+1
				per_locus = []
				per_locus.append(path_in_bubble)
			prev_startsnarl = current_startsnarl
			prev_startsnarl_orientation = current_startsnarl_orientation
			prev_endsnarl = current_endsnarl
			prev_endsnarl_orientation = current_endsnarl_orientation
			locus_branch_mapping[locus_count]=per_locus
	
	canu_bubble_ordering = []
	bubbles_start = set()

	for k,v in locus_branch_mapping.items():
		print(locus_branch_mapping[k][0][0][0])
		start_node_to_bubbleid[locus_branch_mapping[k][0][0][0]] = k  # map start of the bubble to the bubble ID.
		bubbles_start.add(locus_branch_mapping[k][0][0][0])

	with stream.open(str(canu_alignments), "rb") as istream:
		for data in istream:
			g = vg_pb2.Alignment()
			g.ParseFromString(data) 
			for i in range(0,len(g.path.mapping)):
				if g.path.mapping[i].position.node_id in bubbles_start:
					canu_bubble_ordering.append(g.path.mapping[i].position.node_id)
	#for i in [1, 2, 131, 132, 509, 6, 3, 646, 10, 12, 13, 269, 143, 16, 17, 657, 659, 407, 280, 667, 31, 672, 169, 301, 687, 560, 48, 691, 563, 693, 694, 569, 572, 317, 573, 574, 319, 577, 701, 579, 580, 325, 582, 583, 584, 201, 330, 586, 588, 589, 585, 590, 592, 593, 594, 337, 339, 597, 85, 599, 87, 345, 601, 67, 607, 608, 609, 482, 612, 614, 360, 65, 632, 581, 494, 371, 500, 501, 629, 120, 506, 380, 381]:
		#del locus_branch_mapping[i]
	#for i in [7, 8, 12, 15, 19, 20, 22, 23, 27, 29, 31, 32, 35, 38, 40, 42, 43, 45, 46, 52, 53, 59, 60, 61, 62, 63, 65, 69, 70, 71, 72, 78, 81, 82, 87, 91, 92, 94, 98, 100, 102, 104, 108, 114, 115, 118, 127, 128, 129, 142, 149, 156, 162, 163, 164, 165, 167, 170, 171, 172, 177, 182, 185, 186, 195, 198, 203, 211, 212, 213, 216, 223, 226, 227, 229, 231, 233, 235, 237, 238, 242, 243, 248, 249, 258, 259, 260, 266, 270, 271, 272, 273, 277, 278, 280, 287, 288, 290, 295, 298, 299, 301, 304, 305, 307, 308, 310, 311, 312, 315, 316, 317, 319, 322, 323, 328, 330, 335, 338, 340, 343, 346, 347, 348, 351, 354, 362, 364, 366, 367, 368, 369, 372, 373, 379, 383, 384, 385, 387, 391, 392, 394, 395, 396, 397, 399, 403, 404, 405, 406, 407, 409, 411, 413, 415, 417, 419, 422, 425, 428, 429, 432, 433, 436, 437, 438, 440, 442, 443, 444, 446, 452, 453, 458, 459, 462, 464, 465, 467]:
		#del locus_branch_mapping[i]
	#for i in [5, 19, 20, 22, 23, 27, 29, 31, 32, 35, 38, 40, 42, 43, 45, 46, 52, 53, 59, 60, 61, 62, 63, 65, 69, 70, 71, 72, 78, 81, 82, 87, 91, 92, 94, 98, 100, 102, 104, 108, 114, 115, 118, 127, 128, 129, 142, 149, 156, 162, 163, 164, 165, 167, 170, 171, 172, 177, 182, 185, 186, 195, 198, 203, 211, 212, 213, 216, 223, 226, 227, 229, 231, 233, 235, 237, 238, 242, 243, 248, 249, 258, 259, 260, 266, 270, 271, 272, 273, 277, 278, 280, 287, 288, 290, 295, 298, 299, 301, 304, 305, 307, 308, 310, 311, 312, 315, 316, 317, 319, 322, 323, 328, 330, 335, 338, 340, 343, 346, 347, 348, 351, 354, 362, 364, 366, 367, 368, 369, 372, 373, 379, 383, 384, 385, 387, 391, 392, 394, 395, 396, 397, 399, 403, 404, 405, 406, 407, 409, 411, 413, 415, 417, 419, 422, 425, 428, 429, 432, 433, 436, 437, 438, 440, 442, 443, 444, 446, 452, 453, 458, 459, 462, 464, 465, 467]:
		#del locus_branch_mapping[i]
	#for i in [7, 8, 12, 15, 19, 20, 22, 23, 27, 29, 31, 32, 35, 38, 40, 42, 43, 45, 46, 52, 53, 59, 60, 61, 62, 63, 65, 69, 70, 71, 72, 78, 81, 82, 87, 91, 92, 94, 98, 100, 102, 104, 108, 114, 115, 118, 127, 128, 129, 142, 149, 156, 162, 163, 164, 165, 167, 170, 171, 172, 177, 182, 185, 186, 195, 198, 203, 211, 212, 213, 216, 223, 226, 227, 229, 231, 233, 235, 237, 238, 242, 243, 248, 249, 258, 259, 260, 266, 270, 271, 272, 273, 277, 278, 280, 287, 288, 290, 295, 298, 299, 301, 304, 305, 307, 308, 310, 311, 312, 315, 316, 317, 319, 322, 323, 328, 330, 335, 338, 340, 343, 346, 347, 348, 351, 354, 362, 364, 366, 367, 368, 369, 372, 373, 379, 383, 384, 385, 387, 391, 392, 394, 395, 396, 397, 398, 399, 400, 401, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 422, 425, 428, 429, 432, 433, 436, 437, 438, 440, 442, 443, 444, 446, 452, 453, 458, 459, 462, 464, 465, 467]:
		#del locus_branch_mapping[i]
	#for i in [7, 8, 12, 15, 19, 20, 22, 23, 27, 29, 31, 32, 35, 38, 40, 42, 43, 45, 46, 52, 53, 59, 60, 61, 62, 63, 65, 69, 70, 71, 72, 78, 81, 82, 87, 91, 92, 94, 98, 100, 102, 104, 108, 114, 115, 118, 127, 128, 129, 142, 149, 156, 162, 163, 164, 165, 167, 170, 171, 172, 177, 182, 185, 186, 195, 198, 203, 211, 212, 213, 216, 223, 226, 227, 229, 231, 233, 235, 237, 238, 242, 243, 248, 249, 258, 259, 260, 266, 270, 271, 272, 273, 277, 278, 280, 287, 288, 290, 295, 298, 299, 301, 304, 305, 307, 308, 310, 311, 312, 315, 316, 317, 319, 322, 323, 328, 330, 335, 338, 340, 343, 346, 347, 348, 351, 354, 362, 364, 366, 367, 368, 369, 372, 373, 379, 383, 384, 385, 387, 391, 392, 394, 395, 396, 397, 399, 403, 404, 405, 406, 407, 409, 411, 413, 415, 417, 419, 422, 425, 428, 429, 432, 433, 436, 437, 438, 440, 442, 443, 444, 446, 452, 453, 458, 459, 462, 464, 465, 467]:
		#del locus_branch_mapping[i]
	#for i in [395, 396]:
		#del locus_branch_mapping[i]
	

	#print(locus_branch_mapping)
	print('The number of hets:')
	het_count= 0
	for k,v in locus_branch_mapping.items():
		if len(v) >1:
			het_count = het_count +1
	print(het_count)
	# keep branch of paths in each bubble.
	alleles_per_pos= defaultdict()
	for k,v in locus_branch_mapping.items():
		alleles_per_pos[k]=len(v)

	# both simple and complex bubbles: key is the values in locus_branch_mapping and value is triplet(locus, branch, alleles)
	reverse_mapping= defaultdict(list)
	for k,v in locus_branch_mapping.items():
		if len(v) > 1: # more than one branch
			for i,b in enumerate(v):
				if len(b) > 0:
					for p,j in enumerate(b):
						reverse_mapping[j].append([k,i, len(v)]) # in complex bubbles, a node can map to multiple branches.
	#print(reverse_mapping)
	print(locus_branch_mapping)
	canu_bubbleid_ordering = []
	for i in canu_bubble_ordering:
		canu_bubbleid_ordering.append(start_node_to_bubbleid[i])
	
	canu_bubbleid_ordering_unfolded = []
	max_value = max(canu_bubbleid_ordering)
	tmp = []
	for i in canu_bubbleid_ordering:
		max_value+=1
		if i in tmp:
			canu_bubbleid_ordering_unfolded.append(max_value)
		else:
			canu_bubbleid_ordering_unfolded.append(i)
			


	# both simple and complex bubbles: extract reads from GAM file associated with the locus and create a sorted readset.
	# in complex bubble, set of nodes uniquely determine the path. 
	readset=ReadSet()
	unfolded_readset = ReadSet()
	count =0
	duplicated = 0
	#TODO: consider reads with only positive score.
	with stream.open(str(gam_file), "rb") as istream:
		for data in istream:
			g = vg_pb2.Alignment()
			g.ParseFromString(data) 
			# hard-coded source id, mapping quality and other values.
			val1 = True
			val2 = False

			count1 =0
			count2=0
			score = g.score/len(g.sequence)
			#if g.name in duplicate_alns:
			#	continue
			if score > 0.2:
				continue
			read=Read(g.name, 0, 0, 0) # create read for each read alignment
			#readnames= ["S1_Y12_290","S1_SK1_290","S1_Y12_430","S1_SK1_657","S1_Y12_139","S1_Y12_427","S1_SK1_427","S1_Y12_657","S1_SK1_588","S1_Y12_588","S1_SK1_139","S1_SK1_430","S1_Y12_76","S1_Y12_463","S1_SK1_463","S1_SK1_76"]
			#readnames = ["S1_Y12_259"]
			#if g.name not in readnames:
				#continue
			#print(g.name)
			prev_tmp=[]
			prev_locus= -1
			locus = -1
			#for i in range(0,len(g.path.mapping)):
				#if g.path.mapping[i].position.is_reverse != val1:
					#val1 = False
					#break
				#else:
					#count1 = count1 +1
					
			#if count1 == len(g.path.mapping):
				#count = count+1
				##print(g.name)
				
			#for i in range(0,len(g.path.mapping)):
				#if g.path.mapping[i].position.is_reverse != val2:
					#val2 = True
					#break
				#else:
					#count2 = count2 +1
					
			#if count2 == len(g.path.mapping):
				#count = count+1
				##print(g.name)
			#print(val1)
			#print(val2)
			#if val1 ==val2:
			
			for i in range(0,len(g.path.mapping)-1):
			#for i in g.path.mapping: # go over the mapping in a read
				# TODO: check for forward or reverse strand, we may not need it for DAG.
				edge1 = tuple((g.path.mapping[i].position.node_id, g.path.mapping[i+1].position.node_id)) # go over nodes in a mapping
				edge2 = tuple((g.path.mapping[i+1].position.node_id, g.path.mapping[i].position.node_id)) # go over nodes in a mapping
				if edge1 in reverse_mapping or edge2 in reverse_mapping: # handle start and sink node.
					if edge1 in reverse_mapping:
						qualities = [10]* reverse_mapping[edge1][0][2]
						node_inf= [tuple(i[0:2]) for i in reverse_mapping[edge1]] # consider (locus, branch)
					else:
						qualities = [10]* reverse_mapping[edge2][0][2]
						node_inf= [tuple(i[0:2]) for i in reverse_mapping[edge2]]
					tmp = [x for x in node_inf]
					if prev_locus != tmp[0][0]:
						prev_tmp = tmp
						prev_locus = tmp[0][0]
						
					interset_tmp= list(set(tmp).intersection(set(prev_tmp)))
					if len(prev_tmp) > 0 and len(set(tmp).intersection(set(prev_tmp)))==1: # for complicated bubbles, but with Top-k paths. combination of some nodes uniquely determine branch.
						qualities[interset_tmp[0][1]] = 0
						if i== len(g.path.mapping)-2:
							read.add_variant(interset_tmp[0][0], interset_tmp[0][1], qualities)
						else:
							next_edge1 = tuple((g.path.mapping[i+1].position.node_id, g.path.mapping[i+2].position.node_id))
							next_edge2 = tuple((g.path.mapping[i+2].position.node_id, g.path.mapping[i+1].position.node_id))

							if next_edge1 not in reverse_mapping and next_edge2 not in reverse_mapping:
								read.add_variant(interset_tmp[0][0], interset_tmp[0][1], qualities)    

						locus= interset_tmp[0][0]
						
					#if prev_locus!=locus:
						#prev_tmp = []
					#else:
						#for i in tmp:
							#prev_tmp.append(i)
					#prev_locus = locus
			#print(read)
			print(len(canu_bubbleid_ordering))
			if len(read) >= 2 and len(canu_bubbleid_ordering) > 0:
				bubble_list = []
				for variant in read:
					bubble_list.append(variant.position)
			
				print('i am in bubble')
				print(bubble_list)
				print(canu_bubbleid_ordering)
				print(canu_bubbleid_ordering_unfolded)
				
				if len(set(canu_bubbleid_ordering).intersection(set(bubble_list))) > 2:
					
					#matches_in_string = []
					if fuzzy_trincot(canu_bubbleid_ordering, bubble_list, True)!= False:
						segments, segments_index = fuzzy_trincot(canu_bubbleid_ordering, bubble_list, True)
						read_unfolded = Read(read.name, 0, 0, 0)
						for i in range(0,len(segments_index)-1,2):
							
							tmp = []
							if segments_index[i+1]-segments_index[i] == 1:
								tmp.append(bubble_list[segments_index[i]])
								#tmp.append(bubble_list[segments_index[i+1]])
							else:
								for k in range(segments_index[i], segments_index[i+1], 1):
									tmp.append(bubble_list[k])
								
								result = find_matches(tmp, canu_bubbleid_ordering)
								print('i am in result')
								print(result)
							#matches_in_string.append(result[0])
							#matches_in_string.append(result[-1])
						
								#if len(result) == 1: #TODO: if exact match or with some reverses
								print('i am found')
								#index_bubbleid = defaultdict()
								#found = find_matches(bubble_list, canu_bubbleid_ordering)
								unfolded_vs_folded = defaultdict()
								for p in result:
									#index_bubbleid[canu_bubbleid_ordering[i]] = result[i] 
									
									unfolded_vs_folded[canu_bubbleid_ordering[p]] = canu_bubbleid_ordering_unfolded[p]
							
									for variant in read:
										print('i am in variant')
										print(variant.position)
										print(canu_bubbleid_ordering[p])
										if variant.position == canu_bubbleid_ordering[p]:
											read_unfolded.add_variant(unfolded_vs_folded[variant.position], variant.allele, variant.quality)
						unfolded_readset.add(read_unfolded)
						print(read_unfolded)
						
					if fuzzy_trincot(canu_bubbleid_ordering, reversed(bubble_list), True)!= False:
						segments, segments_index = fuzzy_trincot(canu_bubbleid_ordering, reversed(bubble_list), True)
						read_unfolded = Read(read.name, 0, 0, 0)
						for i in range(0,len(segments_index)-1,2):
							
							tmp = []
							if segments_index[i+1]-segments_index[i] == 1:
								tmp.append(reversed(bubble_list)[segments_index[i]])
								#tmp.append(bubble_list[segments_index[i+1]])
							else:
								for k in range(segments_index[i], segments_index[i+1], 1):
									tmp.append(reversed(bubble_list)[k])
								
								result = find_matches(tmp, canu_bubbleid_ordering)
								print('i am in result')
								print(result)
							#matches_in_string.append(result[0])
							#matches_in_string.append(result[-1])
						
								#if len(result) == 1: #TODO: if exact match or with some reverses
								print('i am found')
								#index_bubbleid = defaultdict()
								#found = find_matches(bubble_list, canu_bubbleid_ordering)
								unfolded_vs_folded = defaultdict()
								for p in result:
									#index_bubbleid[canu_bubbleid_ordering[i]] = result[i] 
									
									unfolded_vs_folded[canu_bubbleid_ordering[p]] = canu_bubbleid_ordering_unfolded[p]
							
									for variant in read:
										print('i am in variant')
										print(variant.position)
										print(canu_bubbleid_ordering[p])
										if variant.position == canu_bubbleid_ordering[p]:
											read_unfolded.add_variant(unfolded_vs_folded[variant.position], variant.allele, variant.quality)
						unfolded_readset.add(read_unfolded)
						print(read_unfolded)
					
					#TODO: handle reverse case of bubble list
					#if len(find_matches(reversed(bubble_list), canu_bubbleid_ordering)) == 1: #TODO: if exact match or with some reverses
						#print('i am found')
						#index_bubbleid = defaultdict()
						#found = find_matches(reversed(bubble_list), canu_bubbleid_ordering)
						#for i in range(0,len(reversed(bubble_list))):
							#index_bubbleid[reversed(bubble_list)[i]] = found[i]
						#read_unfolded = Read(read.name, 0, 0, 0)
						#for variant in read:
						#read_unfolded.add_variant(canu_bubbleid_ordering_unfolded[index_bubbleid[variant.position]], variant.allele, variant.qualities)
						#unfolded_readset.add(read_unfolded)
						#print(read_unfolded)
						
					
				readset.add(read)
				
	#print("non-shattered")
	#print(count)
	##print(readset)
	#readset1=ReadSet()
	#tmp_duplicated=set()
	#for read in readset:
		#if read.sort() ==1:
			#duplicated = duplicated +1
			#tmp=[]
			#for variant in read:
				#tmp.append(variant.position)
			#print("duplicated variant")
			#x = [item for item, count in collections.Counter(tmp).items() if count > 1]
			#for a in x:
				#tmp_duplicated.add(a)
			#continue
		#else:
			#if len(read) >=2:
			      #readset1.add(read)
	#print("length of duplicated bubbles")
	#print(tmp_duplicated)
	#print(len(list(tmp_duplicated)))


	#readset1.sort()
	
	print("non-shattered")
	print(count)
	#print(readset)
	readset1_unfolded=ReadSet()
	tmp_duplicated_unfolded=set()
	for read in unfolded_readset:
		if read.sort() ==1:
			duplicated = duplicated +1
			tmp=[]
			for variant in read:
				tmp.append(variant.position)
			print("duplicated variant")
			x = [item for item, count in collections.Counter(tmp).items() if count > 1]
			for a in x:
				tmp_duplicated_unfolded.add(a)
			continue
		else:
			if len(read) >=20:
			      readset1_unfolded.add(read)
	print("length of duplicated bubbles")
	print(tmp_duplicated_unfolded)
	print(len(list(tmp_duplicated_unfolded)))


	readset1_unfolded.sort()
	
	# merge the chopped alignments into one alignment for the current implementation of aligner, it is dictionary of list of lists.
	#orderalignment = defaultdict(list)
	#for read in readset1:
	#	read_name = '_'.join(str(read.name).split('_')[:-1])
	#	#print(read_name)
	#	read_order = int(str(read.name).split('_')[-1])
	#	#print(read_order)
	#	orderalignment[read_name].insert(read_order, read)
	      
	#New_ReadSet= ReadSet()
	#for k,v in orderalignment.items():
	#	read=Read(k, 0, 0, 0)
	#	for x in v:
	#		for variants in x:
	#			read.add_variant(variants.position, variants.allele, variants.quality)
	#	if len(read) >= 2:
	#		if read.sort()!=1:
	#			New_ReadSet.add(read)
	#New_ReadSet.sort()
	


		
	#print("******")
	#for i,read in enumerate(readset1):
	#	for j,variant in enumerate(read):
	#		print(str(i)+" "+str(variant.position)+" "+str(variant.allele)+ " "+"10")
	#print("******")
	print("duplicated")
	print(duplicated)
	print("reads considered before read-selection")
	print(len(readset1_unfolded))
	print(readset1_unfolded)
	for i,j in zip(canu_bubbleid_ordering_unfolded, canu_bubbleid_ordering):
		if i!=j:
			alleles_per_pos[i] = alleles_per_pos[j]
	return readset1_unfolded, alleles_per_pos, locus_branch_mapping #TODO: if locus_branch_mapping needs to be updated for tandom repeats.


"""
consider only top-k paths from complex bubbles using Yen's algorithm for later.
"""

def k_shortest_paths(G, source, target, k=1, weight='weight'):
	"""Returns the k-shortest paths from source to target in a weighted graph G.
	"""
	if source == target:
		return ([0], [[source]]) 
	   
	length, path = nx.single_source_dijkstra(G, source, target, weight=weight)
	if target not in length:
		raise nx.NetworkXNoPath("node %s not reachable from %s" % (source, target))
		
	lengths = [length[target]]
	paths = [path[target]]
	c = count()		
	B = []						
	G_original = G.copy()	
	
	for i in range(1, k):
		for j in range(len(paths[-1]) - 1):			
			spur_node = paths[-1][j]
			root_path = paths[-1][:j + 1]
			
			edges_removed = []
			for c_path in paths:
				if len(c_path) > j and root_path == c_path[:j + 1]:
					u = c_path[j]
					v = c_path[j + 1]
					if G.has_edge(u, v):
						edge_attr = G.edge[u][v]
						G.remove_edge(u, v)
						edges_removed.append((u, v, edge_attr))
			
			for n in range(len(root_path) - 1):
				node = root_path[n]
				# out-edges
				for u, v, edge_attr in G.copy().edges_iter(node, data=True):
					G.remove_edge(u, v)
					edges_removed.append((u, v, edge_attr))
				
				if G.is_directed():
					# in-edges
					for u, v, edge_attr in G.in_edges_iter(node, data=True):
						G.remove_edge(u, v)
						edges_removed.append((u, v, edge_attr))
			
			spur_path_length, spur_path = nx.single_source_dijkstra(G, spur_node, target, weight=weight)			
			if target in spur_path and spur_path[target]:
				total_path = root_path[:-1] + spur_path[target]
				total_path_length = get_path_length(G_original, root_path, weight) + spur_path_length[target]				
				heappush(B, (total_path_length, next(c), total_path))
				
			for e in edges_removed:
				u, v, edge_attr = e
				G.add_edge(u, v, edge_attr)
					   
		if B:
			(l, _, p) = heappop(B)
			lengths.append(l)
			paths.append(p)
		else:
			break
	
	return (lengths, paths)

def get_path_length(G, path, weight='weight'):
	length = 0
	if len(path) > 1:
		for i in range(len(path) - 1):
			u = path[i]
			v = path[i + 1]
			
			length += G.edge[u][v].get(weight, 1)
	
	return length 

"""
To generate two haplotype sequences.
Assumption: positions in one component occur consecutive
"""
def generate_hap_contigs(sample_superreads, sample_components, node_seq_list, locus_branch_mapping, edge_connections):
	sample = 0
	components = sample_components[sample]

	# TODO: sort components dictionary by value.
	prev_comp = -1
	hap1 =''
	hapseq1= defaultdict(list)
	hapseq2= defaultdict(list)

	for sample, superreads in sample_superreads.items():
		for v1, v2 in zip(*superreads):	
			#TODO: handle ambiguos cases
			b = locus_branch_mapping[v1.position][v1.allele]
			if v1.allele == -2:
				b = locus_branch_mapping[v1.position][1]
			tmp =list()
			if v1.position == 1:
				tmp.append(b[0][0])
			for p,j in enumerate(b):
				tmp.append(j[-1])


			for i in tmp:
				comp = components[v1.position]
				hapseq1[comp].append(node_seq_list[i])

			current_node = tmp[-1]
			while current_node in edge_connections and len(edge_connections[current_node]) ==1:
				hapseq1[comp].append(node_seq_list[edge_connections[current_node][0]])
				current_node = edge_connections[current_node][0]

			#TODO: handle ambiguos cases
			b = locus_branch_mapping[v2.position][v2.allele]
			if v2.allele == -2:
				b = locus_branch_mapping[v2.position][1]
			tmp =list()
			if v2.position == 1:
				tmp.append(b[0][0])
			for p,j in enumerate(b):
				tmp.append(j[-1])

			for i in tmp:
				comp = components[v2.position]
				hapseq2[comp].append(node_seq_list[i])
					
			current_node = tmp[-1]
			while current_node in edge_connections and len(edge_connections[current_node]) ==1:
				hapseq2[comp].append(node_seq_list[edge_connections[current_node][0]])
				current_node = edge_connections[current_node][0]


	for k,v in hapseq1.items():
		hap1=''
		hap2=''
		for v in hapseq1[k]:
			hap1=hap1+v
		for v in hapseq2[k]:
			hap2=hap2+v
		print("I am in component" + str(k))
		print(hap1)
		print(hap2)
		
def generate_hap_contigs_based_on_canu(sample_superreads, sample_components, node_seq_list, locus_branch_mapping, edge_connections, canu_alignments, vg_file):
	#sample = 0
	#components = sample_components[sample]

	edge_connections_sign = defaultdict()
	with stream.open(str(vg_file), "rb") as istream:
		for data in istream:
			l = vg_pb2.Graph()
			l.ParseFromString(data)
			for j in range(len(l.edge)):
				from_edge = getattr(l.edge[j], "from")
				#TODO: check this once, out by default 0 in dict
				from_edge_orientation = 0
				to_edge_orientation = 0
				if l.edge[j].from_start == 'False':
					from_edge_orientation = 1
				if l.edge[j].to_end == 'False':
					to_edge_orientation = 1 # store the orientation of each node
				edge_connections_sign[str(from_edge)+"_"+str(l.edge[j].to)] = str(from_edge_orientation)+"_"+str(to_edge_orientation)

	

	# TODO: sort components dictionary by value.
	prev_comp = -1
	hap1 =''
	hapseq1= defaultdict(list)
	hapseq2= defaultdict(list)
	haplotype_over_bubbles = defaultdict(list)
	haplotype_over_bubbles2 = defaultdict(list)

	for sample, superreads in sample_superreads.items():
		for v1, v2 in zip(*superreads):	
			#TODO: handle ambiguos cases
			b = locus_branch_mapping[v1.position][v1.allele]
			if v1.allele == -2:
				b = locus_branch_mapping[v1.position][1]
			tmp =list()
			# for every start/end node of the bubble, store the haplotype path in the bubble except the sink node of the bubble 
			#if v1.position == 1:
			tmp.append(b[0][0])
			#for i in range(0,len(b)-1):
				#if b[i][1] == b[i+1][0] and b[i][0]!=b[i+1][1]:
					#if b[i][0] not in tmp:
						#tmp.append(b[i][0])
					#if b[i][1] not in tmp:
						#tmp.append(b[i][1])
					#if b[i+1][1] not in tmp:
						#tmp.append(b[i+1][0])

			for p,j in enumerate(b):
				tmp.append(j[-1])
			# To handle consecutive bubbles on the same node.
			if b[0][0] in haplotype_over_bubbles:
				haplotype_over_bubbles[tmp[-1]] = tmp
			else:
				haplotype_over_bubbles[b[0][0]]= tmp
			

	# start from canu contigs and assume each contig is in one component, so no need to check components from whatshap, but can be improved later.
	# take care of reverse complement from bubbles and canu alignments.
	# build the assembly based on Illumina data.
	# check if the repetition involve bubbles or nodes removed for phasing.
	# Just correct whereever u do phasing, otherwise just consider canu contigs.
	with stream.open(str(canu_alignments), "rb") as istream:
		for data in istream:
			g = vg_pb2.Alignment()
			contig_nodes = []
			contig_nodes_seq = ''
			g.ParseFromString(data)
			save_nodes = []
			for i in range(0,len(g.path.mapping)):
				index1 =  g.path.mapping[i].position.node_id
				save_nodes.append(index1)
			print('i am in canu')
				
			for i in range(0,len(g.path.mapping)):
				index1 =  g.path.mapping[i].position.node_id
				orientation = g.path.mapping[i].position.is_reverse
				if index1 not in haplotype_over_bubbles:
					contig_nodes.append(str(index1)+"_"+str(orientation)) # taking ordering from canu
					print('i am in canu1')
				#if index1 == 98000 or index1 == 97995 or index1 == 97987 or index1 == 97985:
					#continue
				#if index1 == 224605 or index1 == 224603 or index1 == 224599 or index1 == 224606:
					#continue
				#if index1 == 209382 or index1 == 148136 or index1 == 247644: # wrong ordering of edges in bubble for example, [(209382, 209381), (247644, 148137), (209381, 247644), (148137, 148136)]])
					#continue

				if index1 in haplotype_over_bubbles: # taking ordering from graph
					for j in range(0, len(haplotype_over_bubbles[index1])):
						print('i am in canu2')
						node1 = haplotype_over_bubbles[index1][j]
						node2 = edge_connections[node1]
						if node2 in haplotype_over_bubbles[index1]:
							print(node1)
							print(node2)
							#if node1 == 116050 or node1 == 135765:
								#continue
							if str(node1) + '_'+str(node2) in edge_connections_sign:
								orientation = edge_connections_sign[str(node1) + '_'+str(node2)]
								if j ==0:
									contig_nodes.append(str(node1)+"_"+ orientation.split("_")[0]) #TODO: take based on graph
								contig_nodes.append(str(node2)+"_"+ orientation.split("_")[1])

							#if node2 in save_nodes:
							#	i = save_nodes.index(node2) + 1 # TODO: also check this.

						node1_tmp = haplotype_over_bubbles[index1][len(haplotype_over_bubbles[index1]) - j-1]
						node2_tmp = edge_connections[node1_tmp]
						if node2_tmp in haplotype_over_bubbles[index1]:
							print('hello')
							print(node1_tmp)
							print(node2_tmp)
							if str(node1_tmp) + '_'+str(node2_tmp) in edge_connections_sign:
								orientation = edge_connections_sign[str(node1_tmp) + '_'+str(node2_tmp)]
								if j ==0:
									contig_nodes.append(str(node1_tmp)+"_"+ orientation.split("_")[0]) #TODO: take based on graph
								contig_nodes.append(str(node2_tmp)+"_"+ orientation.split("_")[1])
								#if node2 in save_nodes:
								#	i = save_nodes.index(node2) + 1 # TODO: also check this.
							 #else:
								#orientation = edge_connections_sign[str(node2_tmp) + '_'+str(node1_tmp)]
								#if j ==0:
									#contig_nodes.append(str(node2_tmp)+"_"+ orientation.split("_")[0]) #TODO: take based on graph
								#contig_nodes.append(str(node1_tmp)+"_"+ orientation.split("_")[1])
								#if node1 in save_nodes:
								#	i = save_nodes.index(node1) + 1 # TODO: also check this.
					if node2 in save_nodes and node1 in save_nodes and node1_tmp in save_nodes and node2_tmp in save_nodes:
						i = max(max(max(save_nodes.index(node1), save_nodes.index(node2)), save_nodes.index(node1_tmp)), save_nodes.index(node2_tmp)) + 1
								
			# build the contig sequence taking care of reverse complements for every canu contigs
			print(contig_nodes)
			for i in contig_nodes:
				if i.split("_")[1] == '1':
					contig_nodes_seq = ''.join(reversecomplement(node_seq_length[i])) #TODO: define reversecomplement and check concatenation of string
				else:
					contig_nodes_seq = ''.join(node_seq_length[i])
	#Now do it for haplotype 2 also.
			




# GAM file for hap1 and hap2 in separate and store the information how many times the reads traverse the position for each hap1 and hap2 separately.		
def get_coverage_monitor(gam_file, read_partitions_dict):
	coverage_monitor_hap1= defaultdict(int)
	coverage_monitor_hap2= defaultdict(int)

	with stream.open(str(gam_file), "rb") as istream:
		for data in istream:
			g = vg_pb2.Alignment()
			g.ParseFromString(data)
			if g.name in read_partitions_dict:
				if read_partitions_dict[g.name] == 1:
					for i in range(0,len(g.path.mapping)):
						index1 =  g.path.mapping[i].position.node_id
						coverage_monitor_hap1[index1] +=1
				
	with stream.open(str(gam_file), "rb") as istream:
		for data in istream:
			g = vg_pb2.Alignment()
			g.ParseFromString(data)
			if g.name in read_partitions_dict:
				if read_partitions_dict[g.name] == 0:
					for i in range(0,len(g.path.mapping)):
						index1 =  g.path.mapping[i].position.node_id
						coverage_monitor_hap2[index1] +=1
	print("I am in coverage_monitor_hap1")
	#print(coverage_monitor_hap1)
	#print(coverage_monitor_hap2)
	return coverage_monitor_hap1, coverage_monitor_hap2

#Traverse all the nodes between destination of bubble and start of next bubble

#
# Return all distinct simple paths from "originNode" to "targetNode".
# We are given the graph in the form of a adjacency list "nodeToNodes".
#
def getAllSimplePaths(originNode, targetNode, nodeToNodes):
	print(originNode, targetNode)
	print('I am in getAllSimplePaths')
	print(len(nodeToNodes))
	return helpGetAllSimplePaths(targetNode,[originNode], list(originNode), nodeToNodes, list())
 
#
# Return all distinct simple paths ending at "targetNode", continuing
# from "currentPath". "usedNodes" is useful so we can quickly skip
# nodes we have already added to "currentPath". When a new solution path
# is found, append it to "answerPaths" and return it.
#
def helpGetAllSimplePaths(targetNode,  currentPath,  usedNodes,  nodeToNodes,  answerPaths):
	print('I am in helpGetAllSimplePaths')

	lastNode = currentPath[-1]
	print(lastNode)
	print(targetNode)
	if lastNode == targetNode:
		answerPaths.append(list(currentPath))
	else:
		for neighbor in nodeToNodes[lastNode]:
			print('I am in else')
			if usedNodes.count(neighbor) <=1:
				currentPath.append(neighbor)
				usedNodes.append(neighbor)
				if len(currentPath) > 1000:
					return None
				helpGetAllSimplePaths(targetNode,  currentPath,  usedNodes,  nodeToNodes,  answerPaths)
				usedNodes.remove(neighbor)
				currentPath.pop()
	return answerPaths

    
#take avrage length of reads traversing nodes from hap1 and hap2 separately.
def calculate_avg_RL(visited, coverage_monitor_hap, node_seq_list):
	total_length = 0
	per_node = 0
	for i in list(visited):
		total_length+=coverage_monitor_hap[i]
		per_node += coverage_monitor_hap[i]* len(node_seq_list[i])
	return per_node/total_length
		

def generate_hap_contigs_avgRL(sample_superreads, sample_components, node_seq_list, locus_branch_mapping, edge_connections, edge_connections_tmp, gam_file, read_partitions_dict, nodes_in_bubbles):
	sample = 0
	components = sample_components[sample]
	
		
	# TODO: sort components dictionary by value.
	prev_comp = -1
	hap1 =''
	hapseq1= defaultdict(list)
	hapseq2= defaultdict(list)
	start_bubbles_hap1 = []
	start_bubbles_hap2 = []
	end_bubbles_hap1 = []
	end_bubbles_hap2 = []
	G = nx.DiGraph()
	for k,v in edge_connections.items():
		G.add_node(k)
		for v1 in v:
			G.add_node(v1)
			G.add_edge(k,v1)
	for k,v in G.out_degree().items():
		if v ==0:
			destination_node = k
	for k,v in G.in_degree().items():
		if v ==0:
			source_node = k

	
	
	for sample, superreads in sample_superreads.items():
		for v1, v2 in zip(*superreads):	
			#TODO: handle ambiguos cases
			b = locus_branch_mapping[v1.position][v1.allele]
			if v1.allele == -2:
				b = locus_branch_mapping[v1.position][1]
			print('I am in b1')
			
			tmp =list()
			start_bubbles_hap1.append(b[0][0])
			#if v1.position == 1:
				#tmp.append(b[0][0])
			#for p,j in enumerate(b):
				#tmp.append(j[-1])
			#end_bubbles_hap1.append(tmp[-1])
			

				
			b = locus_branch_mapping[v2.position][v2.allele]
			if v1.allele == -2:
				b = locus_branch_mapping[v2.position][1]
			print('I am in b2')
			
			tmp =list()
			start_bubbles_hap2.append(b[0][0])
			#if v2.position == 1:
				#tmp.append(b[0][0])
			#for p,j in enumerate(b):
				#tmp.append(j[-1])
			#end_bubbles_hap2.append(tmp[-1])
			
	print(len(start_bubbles_hap1))
	print(len(start_bubbles_hap2))
	#print(len(end_bubbles_hap1))
	#print(len(end_bubbles_hap2))
	# TODO: still need to take care of the sequence based on reads before the first bubble, it maybe a complex region.
	# TODO: still need to take care of the orientation of the nodeseq of nodes
	for sample, superreads in sample_superreads.items():
		for v1, v2 in zip(*superreads):	
			#TODO: handle ambiguos cases
			b = locus_branch_mapping[v1.position][v1.allele]
			if v1.allele == -2:
				b = locus_branch_mapping[v1.position][1]
			tmp =list()
			look_up_node = b[0][0]
			if v1.position == 1:
				tmp.append(b[0][0])
			for p,j in enumerate(b):
				tmp.append(j[-1])


			for i in tmp:
				comp = components[v1.position]
				hapseq1[comp].append(node_seq_list[i])

			current_node = tmp[-1]
			# find all the nodes betwen source and destination and then find their coverage for hap1 and hap2 and then take sequences of nodes and then take average.
			while current_node in edge_connections and len(edge_connections[current_node]) ==1:
				hapseq1[comp].append(node_seq_list[edge_connections[current_node][0]])
				current_node = edge_connections[current_node][0]
				nodes_in_bubbles.append(current_node)
				
			nodes_in_bubbles = nodes_in_bubbles[:-1]
			# need to get the destination position...
			print('list index of order')
			print(len(start_bubbles_hap1))
			print(start_bubbles_hap1.index(look_up_node))
			if start_bubbles_hap1.index(look_up_node) < len(start_bubbles_hap1):
				destination = start_bubbles_hap1.index(look_up_node)+1
				#source_index = start_bubbles_hap1.index(look_up_node)
				#current_node_end = end_bubbles_hap1[source_index]
				print('I am here')
				#print(edge_connections)
				print(current_node)
				print(start_bubbles_hap1[destination])
				# To take care of end or start of traversal
				#TODO: it can be handed using nodes_in_bubbles too... check it.
				

				paths = nx.all_simple_paths(G, source=current_node, target=start_bubbles_hap1[destination], cutoff=500)
				
				#visited_nodes_start = getAllSimplePaths(str(current_node), str(start_bubbles_hap1[destination]), edge_connections_tmp)
				#print(list(bfs(edge_connections, current_node, start_bubbles_hap1[destination], nodes_in_bubbles)))
				visited_nodes_start = list(paths)
				print("all simple paths")
				print(len(visited_nodes_start))
				
				final_nodes =set()
				for j in visited_nodes_start:
					for i in j:
						if i not in nodes_in_bubbles:
							final_nodes.add(i)
				#visited_nodes_end = getAllSimplePaths(str(current_node), str(end_bubbles_hap1[destination]), edge_connections_tmp)
				##print(list(bfs(edge_connections, current_node, start_bubbles_hap1[destination], nodes_in_bubbles)))
				
				#final_nodes_end =set()
				#for j in visited_nodes_end:
					#for i in j:
						#final_nodes_end.add(i)
				#visited_nodes_start1 = getAllSimplePaths(str(current_node_end), str(start_bubbles_hap1[destination]), edge_connections_tmp)
				##print(list(bfs(edge_connections, current_node, start_bubbles_hap1[destination], nodes_in_bubbles)))
				
				#final_nodes_start1 =set()
				#for j in visited_nodes_start1:
					#for i in j:
						#final_nodes_start1.add(i)
				#visited_nodes_end1 = getAllSimplePaths(str(current_node_end), str(end_bubbles_hap1[destination]), edge_connections_tmp)
				##print(list(bfs(edge_connections, current_node, start_bubbles_hap1[destination], nodes_in_bubbles)))
				
				#final_nodes_end1 =set()
				#for j in visited_nodes_end1:
					#for i in j:
						#final_nodes_end1.add(i)
			#minimum_val = min(min(min(len(final_nodes_start), len(final_nodes_end)), len(final_nodes_start1)), len(final_nodes_end1))

			#if len(final_nodes_start) == minimum_val:
				#final_nodes = final_nodes_start
			#elif len(final_nodes_end) == minimum_val:
				#final_nodes = final_nodes_end
			#elif len(final_nodes_start1) == minimum_val:
				#final_nodes = final_nodes_start1
			#else:
				#final_nodes = final_nodes_end1
			print("I am in visited nodess")
			print(len(final_nodes))
			coverage_monitor_hap1, coverage_monitor_hap2 = get_coverage_monitor(gam_file, read_partitions_dict)
			node_seq_length = calculate_avg_RL(final_nodes, coverage_monitor_hap1, node_seq_list)
			tmp_string_for_cyclic = "N"*node_seq_length
			hapseq1[comp].append(node_seq_length)

			#TODO: handle ambiguos cases
			#b = locus_branch_mapping[v2.position][v2.allele]
			#if v2.allele == -2:
				#b = locus_branch_mapping[v2.position][1]
			#tmp =list()
			#if v2.position == 1:
				#tmp.append(b[0][0])
			#for p,j in enumerate(b):
				#tmp.append(j[-1])

			#for i in tmp:
				#comp = components[v2.position]
				#hapseq2[comp].append(node_seq_list[i])
					
			#current_node = tmp[-1]
			## similarly for hap2
			#while current_node in edge_connections and len(edge_connections[current_node]) ==1:
				#hapseq2[comp].append(node_seq_list[edge_connections[current_node][0]])
				#current_node = edge_connections[current_node][0]
			
			#destination = start_bubbles_hap2.index(current_node)+1
			#visited_nodes = bfs(edge_connections, current_node, start_bubbles_hap2[destination])
			#coverage_monitor_hap1, coverage_monitor_hap2 = get_coverage_monitor(gam_hap1_file, gam_hap2_file)
			#node_seq_length = calculate_avg_RL(visited_nodes, coverage_monitor_hap2)
			#tmp_string_for_cyclic = "N"*node_seq_length
			#hapseq2[comp].append(node_seq_length)


	for k,v in hapseq1.items():
		hap1=''
		hap2=''
		for v in hapseq1[k]:
			hap1=hap1+v
		#for v in hapseq2[k]:
		#	hap2=hap2+v
		print("I am in component" + str(k))
		print(hap1)
		#(hap2)
		
# partition all set of reads by considering the haplotypes from most significant reads. 
def haplotag(pred_superreads, read_set, components, iteration):
	phases = []
	
	for s1,s2 in zip(*pred_superreads):
		VariantCallPhase = namedtuple('VariantCallPhase', ['block_id', 'position', 'phase1', 'phase2'])
		extract_phase = VariantCallPhase(components[s1.position], s1.position, s1.allele, s2.allele)
		phases.append(extract_phase) #TODO: check it
		
	variantpos_to_allele1 = {
		v.position:int(v.allele) for v, v2 in zip(*pred_superreads) if v.allele!=-2
	}
	variantpos_to_allele2 = {
		v2.position:int(v2.allele) for v, v2 in zip(*pred_superreads) if v2.allele!=-2
	}
	
	variantpos_to_phaseset1 = {
		v.position:components[v.position] for v, v2 in zip(*pred_superreads) if v.allele!=-2
	}
	variantpos_to_phaseset2 = {
		v2.position:components[v2.position] for v, v2 in zip(*pred_superreads) if v2.allele!=-2
	}
	read_to_haplotype = {}
	#read_set = read_reads(readset_reader, chromosome_name, variants, sample, fasta)
	for read in read_set:
		# mapping: phaseset --> phred scaled difference between costs of assigning reads to haplotype 0 or 1
		haplotype_costs = defaultdict(int)
		haplotype_costs[0] = 0
		haplotype_costs[1] = 0
		for v in read:
			if v.position not in variantpos_to_allele1 or v.position not in variantpos_to_allele2:
				continue
			phaseset1 = variantpos_to_allele1[v.position]
			phaseset2 = variantpos_to_allele2[v.position]
	
			if v.allele != phaseset1:
				haplotype_costs[0] += 10
			#else:
				#haplotype_costs[0] -= 10
			if v.allele != phaseset2:
				haplotype_costs[1] += 10
			#else:
				#haplotype_costs[1] -= 10
			
		l =[]
		for k,v in haplotype_costs.items():
			l.append(k)
			l.append(v)
		#l = list(haplotype_costs.items())
		if l[1] < l[3]:
			read_to_haplotype[read.name] = (0, l[1], l[0])
		else:
			read_to_haplotype[read.name] = (1, l[3], l[2])
		#l.sort(key=lambda t:-abs(t[1]))
		#phaseset, quality = l[0]
		#if quality != 0:
			#haplotype = 0 if quality > 0 else 1
			#read_to_haplotype[read.name] = (haplotype, abs(quality), phaseset)
			
	f = open('predicted_all_read_partionting' + str(iteration), 'w')
	#accessible_positions = sorted(read_set.get_positions())
	#overall_components = find_components(accessible_positions, read_set)
	for read in read_set:
		#print(read.name)
		for variant in read:
			if variant.allele!=-2:
				phaseset = components[variant.position] + 1
				break
		print(read.name, phaseset, read_to_haplotype[read.name][2], file =f )
	#for k,v in read_to_haplotype.items():
		#print(k, v[2], v[0], file=f)


def compute_read_partitioning_accuracy(true_file):
	true_hap1 =[]
	true_hap2= []
	#f = open(true_file, 'r')
	
	for line in open(true_file):
		if line.split(" ")[1] =='1':
			true_hap1.append(line.split(" ")[0])
		else:
			true_hap2.append(line.split(" ")[0])
		
	pred_hap1 = defaultdict(list)
	pred_hap2 = defaultdict(list)
	total=0
	blocks =set()
	for line in open('predicted_read_partionting'):
		tokens= line.split(" ")
		blocks.add(tokens[1])
		if tokens[2] =='1':
			pred_hap1[tokens[1]].append(tokens[0])
		else:
			pred_hap2[tokens[1]].append(tokens[0])
		total+=1
	
	count = 0
	for k in blocks:
		count += max(len(list(set(pred_hap1[k]).intersection(set(true_hap1)))), len(list(set(pred_hap1[k]).intersection(set(true_hap2)))))
		count += max(len(list(set(pred_hap2[k]).intersection(set(true_hap1)))), len(list(set(pred_hap2[k]).intersection(set(true_hap2)))))
	percent_partitionining_accuracy =  count/total
	print('percent_partitionining_accuracy')
	print(percent_partitionining_accuracy)
	
count_width = 9
class SwitchFlips:
	def __init__(self, switches=0, flips=0):
		self.switches = switches
		self.flips = flips
	def __iadd__(self, other):
		self.switches += other.switches
		self.flips += other.flips
		return self
	def __repr__(self):
		return 'SwitchFlips(switches={}, flips={})'.format(self.switches, self.flips)
	def __str__(self):
		return '{}/{}'.format(self.switches, self.flips)


class PhasingErrors:
	def __init__(self, switches=0, hamming=0, switch_flips=None):
		self.switches = switches
		self.hamming = hamming
		self.switch_flips = SwitchFlips() if switch_flips is None else switch_flips
	def __iadd__(self, other):
		self.switches += other.switches
		self.hamming += other.hamming
		self.switch_flips += other.switch_flips
		return self
	def __repr__(self):
		return 'PhasingErrors(switches={}, hamming={}, switch_flips={})'.format(self.switches, self.hamming, self.switch_flips)


def complement(s):
	t = { '0': '1', '1':'0' }
	return ''.join(t[c] for c in s)


def hamming(s0, s1):
	assert len(s0) == len(s1)
	return sum( c0!=c1 for c0, c1 in zip(s0, s1) )


def switch_encoding(phasing):
	return ''.join( ('0' if phasing[i-1]==phasing[i] else '1') for i in range(1,len(phasing)) )


def compute_switch_flips(phasing0, phasing1):
	assert len(phasing0) == len(phasing1)
	s0 = switch_encoding(phasing0)
	s1 = switch_encoding(phasing1)
	result = SwitchFlips()
	switches_in_a_row = 0
	for i, (p0, p1) in enumerate(zip(s0, s1)):
		if p0 != p1:
			switches_in_a_row += 1
		if (i + 1 == len(s0)) or (p0 == p1):
			result.flips += switches_in_a_row // 2
			result.switches += switches_in_a_row % 2
			switches_in_a_row = 0
	if False:
		print('switch_flips():')
		print('   phasing0={}'.format(phasing0))
		print('   phasing1={}'.format(phasing1))
		print('         s0={}'.format(s0))
		print('         s1={}'.format(s1))
		print('   switches={}, flips={}'.format(result.switches, result.flips))
	return result


def compare_block(phasing_pred1, phasing_pred2, phasing_true1, phasing_true2):
	"""Input are two strings over {0,1}. Output is a PhasingErrors object."""
	return PhasingErrors(
		switches = min(min(hamming(switch_encoding(phasing_pred1), switch_encoding(phasing_true1)), hamming(switch_encoding(phasing_pred1), switch_encoding(phasing_true2))), min(hamming(switch_encoding(phasing_pred2), switch_encoding(phasing_true1)), hamming(switch_encoding(phasing_pred2), switch_encoding(phasing_true2)))),
		hamming = min(min(hamming(phasing_pred1, phasing_true1), hamming(phasing_pred1, phasing_true2)), min(hamming(phasing_pred2, phasing_true1), hamming(phasing_pred2, phasing_true2))), switch_flips=SwitchFlips()
		)
      
def fraction2percentstr(nominator, denominator):
	if denominator == 0:
		return '--'
	else:
		return '{:.2f}%'.format(nominator*100.0/denominator)


def safefraction(nominator, denominator):
	if denominator == 0:
		return float('nan')
	else:
		return nominator/denominator


def create_bed_records(chromosome, phasing0, phasing1, positions, annotation_string):
	"""Determines positions of switch errors between two phasings
	and yields one BED record per switch error (encoded as a tuple).
	The annotation_string is added to each record."""
	assert len(phasing0) == len(phasing1) == len(positions)
	switch_encoding0 = switch_encoding(phasing0)
	switch_encoding1 = switch_encoding(phasing1)
	for i, (sw0, sw1) in enumerate(zip(switch_encoding0, switch_encoding1)):
		if sw0 != sw1:
			yield (chromosome, positions[i]+1, positions[i+1]+1, annotation_string)


def print_errors(errors, phased_pairs, print_hamming=False):
	print('    phased pairs of variants assessed:', str(phased_pairs).rjust(count_width))
	print('                        switch errors:', str(errors.switches).rjust(count_width))
	print('                    switch error rate:', fraction2percentstr(errors.switches, phased_pairs).rjust(count_width))
	print('            switch/flip decomposition:', str(errors.switch_flips).rjust(count_width) )
	print('                     switch/flip rate:', fraction2percentstr(errors.switch_flips.switches+errors.switch_flips.flips, phased_pairs).rjust(count_width))
      
pairwise_comparison_results_fields = [
	'intersection_blocks',
	'covered_variants',
	'all_assessed_pairs',
	'all_switches',
	'all_switch_rate',
	'all_switchflips',
	'all_switchflip_rate',
	'largestblock_assessed_pairs',
	'largestblock_switches',
	'largestblock_switch_rate',
	'largestblock_switchflips',
	'largestblock_switchflip_rate',
	'largestblock_hamming',
	'largestblock_hamming_rate'
]
PairwiseComparisonResults = namedtuple('PairwiseComparisonResults', pairwise_comparison_results_fields)

# TO compare the true and predicted superreads.
# assumption here that true_superreads are in one component
# Get true_haplotypes also at the same positions as predicted
def compare(predicted_superreads, true_superreads, components):
	phases_pred1 = defaultdict()
	phases_pred2 = defaultdict()
	phases_true1 = defaultdict()
	phases_true2 = defaultdict()
	
	for s1,s2 in zip(*predicted_superreads):
		#VariantCallPhase = namedtuple('VariantCallPhase', ['block_id', 'position','phase'])
		#extract_phase = VariantCallPhase(components[s1.position], s1.position, s1.allele)
		if s1.allele !=-2 and s2.allele !=-2:
			phases_pred1[s1.position] = s1.allele
			phases_pred2[s1.position] = s2.allele 

	for s1,s2 in zip(*true_superreads):
		#VariantCallPhase = namedtuple('VariantCallPhase', ['block_id', 'position','phase'])
		#extract_phase = VariantCallPhase(components[s1.position], s1.position, s1.allele)
		if s1.allele !=-2 and s2.allele !=-2:
			phases_true1[s1.position] = s1.allele
			phases_true2[s1.position] = s2.allele 

	
	blocks = defaultdict(list)
	for k,v in phases_pred1.items():
		if phases_pred1[k]!=-2 or phases_pred2[k]!=-2 or phases_true1[k]!=-2 or phases_true2[k]!=-2:
			if k in phases_true1 and k in phases_true2: # to handle the intersection of predicted with true
				blocks[components[k]].append(k)
	intersection_block_variants = sum(len(b) for b in blocks.values() if len(b) > 1)
	
	longest_block = None
	longest_block_errors = None
	phased_pairs = 0
	bed_records = []

	total_errors = PhasingErrors()
	for block in blocks.values():
		if len(block) < 2:
			continue
		phasing_pred1 = ''.join( str(phases_pred1[i]) for i in block )
		phasing_pred2 = ''.join( str(phases_pred2[i]) for i in block )
		phasing_true1 = ''.join( str(phases_true1[i]) for i in block )
		phasing_true2 = ''.join( str(phases_true2[i]) for i in block )
		block_positions = [ i for i in block ]
		errors = compare_block(phasing_pred1, phasing_pred2, phasing_true1, phasing_true2)
		#bed_records.extend(create_bed_records(chromosome, phasing0, phasing1, block_positions, '{}<-->{}'.format(*dataset_names)))
		total_errors += errors
		phased_pairs += len(block) - 1
		if (longest_block is None) or (len(block) > longest_block):
			longest_block = len(block)
			longest_block_errors = errors
	print('              ALL INTERSECTION BLOCKS:', '-'*count_width)
	print_errors(total_errors, phased_pairs)
	print('           LARGEST INTERSECTION BLOCK:', '-'*count_width)
	print_errors(longest_block_errors, longest_block-1)
	print('                     Hamming distance:', str(longest_block_errors.hamming).rjust(count_width))
	print('                 Hamming distance [%]:', fraction2percentstr(longest_block_errors.hamming, longest_block).rjust(count_width))
	print('%phased error rate', safefraction(total_errors.switches, phased_pairs))
	print('number of blocks', len(blocks.values()))
	return PairwiseComparisonResults(
		intersection_blocks = len(blocks.values()),
		covered_variants = intersection_block_variants,
		all_assessed_pairs = phased_pairs,
		all_switches = total_errors.switches,
		all_switch_rate = safefraction(total_errors.switches, phased_pairs),
		all_switchflips = -1,
		all_switchflip_rate = -1,
		largestblock_assessed_pairs = longest_block-1,
		largestblock_switches = longest_block_errors.switches,
		largestblock_switch_rate = safefraction(longest_block_errors.switches, longest_block - 1),
		largestblock_switchflips = -1,
		largestblock_switchflip_rate = -1,
		largestblock_hamming = -1,
		largestblock_hamming_rate = -1
	), bed_records

def compute_coverage_at_variant(selected_reads):
	variant_pos_tocov=defaultdict(int)
	for read in selected_reads:
		for variant in read:
			variant_pos_tocov[variant.position]+=1
	return variant_pos_tocov

#def run_phaseg(locus_file, gam_file, vg_file):
def run_phaseg(locus_file, gam_file, vg_file, canu_alignments, true_haps):
	"""
	Run WhatsHap.

	gam_file -- path to GAM file
	locus_file -- path to LOCUS file
	"""
	recombrate=1.26
	max_coverage = 15
	all_heterozygous = False
	distrust_genotypes = True
	with ExitStack() as stack:
		node_seq_list, edge_connections = vg_graph_reader(vg_file)
		all_reads, alleles_per_pos, locus_branch_mapping = vg_reader(locus_file, gam_file, canu_alignments)
		all_positions = sorted(all_reads.get_positions())
		all_components = find_components(all_positions, all_reads)
		blocks = defaultdict(list)
		print("all_components")
		for position, block_id in all_components.items():
			blocks[block_id].append(locus_branch_mapping[position][0][0][0])
		for k,v in blocks.items():
			print(k,v)
		print("all_components")
		

		#print(all_reads)
		selected_indices = readselection(all_reads, max_coverage)
		selected_reads = all_reads.subset(selected_indices)

		#selected_reads = slice_reads(all_reads, max_coverage)
		#print('positions from all reads')
		#print(len(all_reads.get_positions()))
		print("reads after read-selection")
		print(len(selected_reads))
		print("positions covered by atleast one read after read selection")
		print(len(selected_reads.get_positions()))

		accessible_positions = sorted(selected_reads.get_positions())
		
		print("readset after read_selection")
		#for read in selected_reads:
			#print(read.name)
		pedigree = Pedigree(NumericSampleIds())
		# compute the number of alleles at each position.
		alleles_per_accessible_pos =[]
		genotype_likelihoods = []
		for pos in accessible_positions:
			if pos in alleles_per_pos:
				n_alleles = alleles_per_pos[pos]  
				possible_genotypes = n_alleles +  ncr(n_alleles, 2)
				genotype_likelihoods.append(None if all_heterozygous else PhredGenotypeLikelihoods([0]* possible_genotypes))
		# random input of genotypes, since distrust_genotypes is always ON.
		pedigree.add_individual('individual0', [0]* len(accessible_positions), genotype_likelihoods)
		recombination_costs = uniform_recombination_map(recombrate, accessible_positions)
		# Finally, run phasing algorithm
		#print(selected_reads)
		dp_table = PedigreeDPTable(selected_reads, recombination_costs, pedigree, distrust_genotypes, accessible_positions)
		superreads_list, transmission_vector = dp_table.get_super_reads()

		cost = dp_table.get_optimal_cost()
		print(superreads_list[0])
		#print(cost)
		read_partitions = dp_table.get_optimal_partitioning()
		#print(read_partitions)
		
		## To generate the connected components and corresponding haplotypes.
		print("in components")
		f = open('whole_genome' + '.predicted_read_partionting.pred', 'w')
		overall_components = find_components(accessible_positions, selected_reads)
		
		read_partitions_dict ={}
		for read, haplotype in zip(selected_reads, read_partitions):
			phaseset = overall_components[read[0].position] + 1
			print(read.name, phaseset, haplotype, file=f)
			read_partitions_dict[read.name] = haplotype
		#phaset is blockid

		n_phased_blocks = len(set(overall_components.values()))
		all_phased_blocks = len(set(all_components.values()))
		print('No. of phased blocks: %d', n_phased_blocks)
		largest_component = find_largest_component(overall_components)
		print('No. of blocks from all the reads: %d', all_phased_blocks)
		largest_component_all_reads = find_largest_component(all_components)
		if len(largest_component) > 0:
			print('Largest component contains %d variants',len(largest_component))
		if len(largest_component_all_reads) > 0:
			print('Largest component contains %d variants',len(largest_component_all_reads))
		
		
		### To generate contig sequences
		sample = 0
		superreads, components = dict(), dict()
		superreads[sample] = superreads_list[0]
		components[sample] = overall_components
		#generate_hap_contigs_based_on_canu(superreads_list[0], components[sample], node_seq_list, locus_branch_mapping, edge_connections, canu_alignments, vg_file)
		#generate_hap_contigs(superreads_list[0], overall_components, node_seq_list, locus_branch_mapping, edge_connections)
		
		nodes_in_bubbles =[]
		with stream.open(str(locus_file), "rb") as istream:
			for data in istream:
				l = vg_pb2.SnarlTraversal()
				l.ParseFromString(data)
				for i in range(0,len(l.visits)):
					nodes_in_bubbles.append(l.visits[i].node_id)
				#nodes_in_bubbles.append(l.snarl.end.node_id)
				#nodes_in_bubbles.append(l.snarl.start.node_id)
		edge_connections_tmp = defaultdict(list)
		with stream.open(str(vg_file), "rb") as istream:
			for data in istream:
				l = vg_pb2.Graph()
				l.ParseFromString(data)
				for j in range(len(l.edge)):
					from_edge = getattr(l.edge[j], "from")
					#if from_edge not in nodes_in_bubbles and l.edge[j].to not in nodes_in_bubbles:
					edge_connections_tmp[str(from_edge)].append(str(l.edge[j].to))
					edge_connections_tmp[str(l.edge[j].to)].append(str(from_edge))


		#generate_hap_contigs_based_on_canu(superreads, components, node_seq_list, locus_branch_mapping, edge_connections, canu_alignments, vg_file)
		#generate_hap_contigs_avgRL(superreads, components, node_seq_list, locus_branch_mapping, edge_connections, edge_connections_tmp, gam_file, read_partitions_dict, nodes_in_bubbles)
		
		# evaluation partition all the reads based on one iteration
		#print('partition all the reads based on haplotypes from one iteration')
		# Check here if you wanna do all reads or selected reads only
		#haplotag(superreads_list[0], selected_reads, overall_components, 1)
		
		#compute_read_partitioning_accuracy("true_partioning")



		##generate_hap_contigs(superreads, components, node_seq_list, locus_branch_mapping, edge_connections)
		
		##For phasing accuracy, read true haps and generate corresponding superreads
		#all_reads_true, alleles_per_pos_true, locus_branch_mapping_true = vg_reader(locus_file, true_haps)
		# Finally, run phasing algorithm for true haplotypes
		#dp_table_true = PedigreeDPTable(all_reads_true, recombination_costs, pedigree, distrust_genotypes, accessible_positions)
		#superreads_list_true, transmission_vector_true = dp_table_true.get_super_reads()
		# to compute the phasing accuracy
		#true_haps = ReadSet()
		#for read in all_reads_true:
			#tmp_read = Read(read.name, 0, 0, 0)
			#for variant in read:
				#if variant.position in accessible_positions:
					#tmp_read.add_variant(variant.position, variant.allele, [10])
			#true_haps.add(tmp_read)
		#compare(superreads_list[0], true_haps, overall_components)
		## To perform iterative whatshap phasing
		#remaining_reads =[]
		#for read in all_reads:
			#remaining_reads.append(read.name)
		#prev_superreads = superreads_list[0]
		#for read in selected_reads:
			#remaining_reads.remove(read.name)
		#while len(remaining_reads)>0:
			#print('iteration')
			#iterative_reaset =  ReadSet()
			#for read in all_reads:
				#if read.name in remaining_reads:
					#iterative_reaset.add(read)

				
			#selected_indices = readselection(iterative_reaset, max_coverage)
			#selected_reads = iterative_reaset.subset(selected_indices)
			#for read in prev_superreads:
				#selected_reads.add(read)
				#remaining_reads.append(read.name)
			#accessible_positions = sorted(selected_reads.get_positions())
			#selected_reads.sort()
			#pedigree = Pedigree(NumericSampleIds())
			## compute the number of alleles at each position.
			#alleles_per_accessible_pos =[]
			#genotype_likelihoods = []
			#for pos in accessible_positions:
				#if pos in alleles_per_pos:
					#n_alleles = alleles_per_pos[pos]  
					#possible_genotypes = n_alleles +  ncr(n_alleles, 2)
					#genotype_likelihoods.append(None if all_heterozygous else PhredGenotypeLikelihoods([0]* possible_genotypes))
			## random input of genotypes, since distrust_genotypes is always ON.
			#pedigree.add_individual('individual0', [0]* len(accessible_positions), genotype_likelihoods)
			#recombination_costs = uniform_recombination_map(recombrate, accessible_positions)
			## Finally, run phasing algorithm
			##print(selected_reads)
			#dp_table = PedigreeDPTable(selected_reads, recombination_costs, pedigree, distrust_genotypes, accessible_positions)
			#superreads_list, transmission_vector = dp_table.get_super_reads()
			#for read in selected_reads:
				#remaining_reads.remove(read.name)
			#prev_superreads = superreads_list[0]
			
		#print('I am final')
		#accessible_positions = sorted(all_reads.get_positions())
		#overall_components = find_components(accessible_positions, all_reads)
		#haplotag(superreads_list[0], all_reads, overall_components, "all_iter")
		#compare(superreads_list[0], superreads_list_true[0], overall_components)
		#print(superreads_list[0])
		
		#iterative whatshap for sparse matrices where we fix the phasing for variants at each iteration that reach max coverage.
		



def add_arguments(parser):
	arg = parser.add_argument
	# Positional arguments
	arg('locus_file', metavar='LOCUS', help='variants in LOCUS file to phase')
	arg('gam_file', metavar='PHASEINPUT', help='read alignments in GAM file ')
	arg('vg_file', metavar='GRAPH', help='node-sequence association')
	arg('canu_alignments', metavar='CANU_ALNS', help='contigs from canu.')
	#arg('nodes_file', metavar='NODES', help='node-sequence association')
	arg('true_haps', metavar='TRUE_HAPS', help='compare phasing with true haps in GAM format.')
	#TODO: add k parameter

def main(args):
	run_phaseg(**vars(args))

